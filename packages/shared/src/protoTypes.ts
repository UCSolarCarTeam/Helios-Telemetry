// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.5
//   protoc               v3.20.3
// source: packages/shared/src/.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "";

export enum Motor {
  LeftMotor = 0,
  RightMotor = 1,
  UNRECOGNIZED = -1,
}

export function motorFromJSON(object: any): Motor {
  switch (object) {
    case 0:
    case "LeftMotor":
      return Motor.LeftMotor;
    case 1:
    case "RightMotor":
      return Motor.RightMotor;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Motor.UNRECOGNIZED;
  }
}

export function motorToJSON(object: Motor): string {
  switch (object) {
    case Motor.LeftMotor:
      return "LeftMotor";
    case Motor.RightMotor:
      return "RightMotor";
    case Motor.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface CoordUpdateResponse {
  coords?: Coords | undefined;
  error?: Error | undefined;
}

export interface Coords {
  lat: number;
  long: number;
}

export interface Error {
  error: string;
  invalidFields: string[];
}

export interface CoordInfoUpdate {
  lat: string;
  long: string;
  password: string;
}

export interface ITelemetryData {
  AuxBms: IAuxBms | undefined;
  Battery: IBattery | undefined;
  BatteryFaults: IBatteryFault | undefined;
  Ccs: ICcs | undefined;
  DriverControls: IDriverControls | undefined;
  KeyMotor: IKeyMotor[];
  Lights: ILights | undefined;
  MPPT: IMPPT[];
  MotorDetails: IMotorDetail[];
  MotorFaults: IMotorFault[];
  PacketTitle: string;
  TimeStamp: number;
}

export interface ILapData {
  ampHours: number;
  averagePackCurrent: number;
  averageSpeed: number;
  batterySecondsRemaining: number;
  distance: number;
  lapTime: number;
  netPowerOut: number;
  timeStamp: number;
  totalPowerIn: number;
  totalPowerOut: number;
}

export interface IAuxBms {
  AllowCharge: boolean;
  AllowDischarge: boolean;
  AuxBmsAlive: boolean;
  AuxVoltage: number;
  ChargeContactorError: boolean;
  ChargeNotClosedDueToHighCurrent: boolean;
  ChargeOpenButShouldBeClosed: boolean;
  ChargeShouldTrip: boolean;
  ChargeTripDueToHighCellVoltage: boolean;
  ChargeTripDueToHighTemperatureAndCurrent: boolean;
  ChargeTripDueToPackCurrent: boolean;
  CommonContactorError: boolean;
  DischargeContactorError: boolean;
  DischargeNotClosedDueToHighCurrent: boolean;
  DischargeOpenButShouldBeClosed: boolean;
  DischargeShouldTrip: boolean;
  DischargeTripDueToHighTemperatureAndCurrent: boolean;
  DischargeTripDueToLowCellVoltage: boolean;
  DischargeTripDueToPackCurrent: boolean;
  HighVoltageEnableState: boolean;
  OrionCANReceivedRecently: boolean;
  PrechargeState: string;
  ProtectionTrip: boolean;
  StrobeBmsLight: boolean;
  TripDueToOrionMessageTimeout: boolean;
}

export interface IKeyMotor {
  Alive: boolean;
  BusCurrent: number;
  BusVoltage: number;
  SetCurrent: number;
  SetVelocity: number;
  VehicleVelocity: number;
}

export interface IMotorDetail {
  BackEmf: number;
  DcBusAmpHours: number;
  DspBoardTemp: number;
  HeatSinkTemp: number;
  MotorCurrentImaginary: number;
  MotorCurrentReal: number;
  MotorTemp: number;
  MotorVoltageImaginary: number;
  MotorVoltageReal: number;
  Odometer: number;
  PhaseBCurrent: number;
  PhaseCCurrent: number;
  SlipSpeed: number;
  VoltageRail15VSupply: number;
  VoltageRail1VSupply: number;
  VoltageRail3VSupply: number;
}

export interface IDriverControls {
  Acceleration: number;
  Alive: boolean;
  Aux: boolean;
  Brakes: boolean;
  Forward: boolean;
  Hazard: boolean;
  HeadlightsHigh: boolean;
  HeadlightsLow: boolean;
  HeadlightsOff: boolean;
  Horn: boolean;
  Interior: boolean;
  Lap: boolean;
  NextSong: boolean;
  PrevSong: boolean;
  PushToTalk: boolean;
  RegenBraking: number;
  Reset: boolean;
  Reverse: boolean;
  SignalLeft: boolean;
  SignalRight: boolean;
  VolumeDown: boolean;
  VolumeUp: boolean;
}

export interface ILights {
  Alive: boolean;
  BmsStrobeLight: boolean;
  Brakes: boolean;
  HighBeams: boolean;
  LeftSignal: boolean;
  LowBeams: boolean;
  RightSignal: boolean;
}

export interface IBatteryFault {
  ErrorFlags: IBatteryErrorFlags | undefined;
  LimitFlags: IBatteryLimitFlags | undefined;
}

export interface IBatteryErrorFlags {
  PowerSupplyFault: boolean;
  AlwaysOnSupplyFault: boolean;
  CANBUSCommunicationsFault: boolean;
  ChargeLimitEnforcementFault: boolean;
  ChargerSafetyRelayFault: boolean;
  CurrentSensorFault: boolean;
  DischargeLimitEnforcementFault: boolean;
  FanMonitorFault: boolean;
  HighVoltageIsolationFault: boolean;
  InternalCommunicationFault: boolean;
  InternalConversionFault: boolean;
  InternalLogicFault: boolean;
  InternalMemoryFault: boolean;
  InternalThermistorsFault: boolean;
  LowCellVoltageFault: boolean;
  OpenWiringFault: boolean;
  PackVoltageSensorFault: boolean;
  ThermistorFault: boolean;
  VoltageRedundancyFault: boolean;
  WeakCellFault: boolean;
  WeakPackFault: boolean;
}

export interface IBatteryLimitFlags {
  CclReducedDueToAlternateCurrentLimit: boolean;
  CclReducedDueToChargerLatch: boolean;
  CclReducedDueToHighCellResistance: boolean;
  CclReducedDueToHighCellVoltage: boolean;
  CclReducedDueToHighPackVoltage: boolean;
  CclReducedDueToHighSoc: boolean;
  CclReducedDueToTemperature: boolean;
  DclReducedDueToHighCellResistance: boolean;
  DclReducedDueToLowCellVoltage: boolean;
  DclReducedDueToLowPackVoltage: boolean;
  DclReducedDueToLowSoc: boolean;
  DclReducedDueToTemperature: boolean;
  DclandCclReducedDueToCommunicationFailsafe: boolean;
  DclandCclReducedDueToVoltageFailsafe: boolean;
}

export interface ICcs {
  CcsAlive: boolean;
}

export interface IMPPT {
  Alive: boolean;
  ArrayCurrent: number;
  ArrayVoltage: number;
  BatteryVoltage: number;
  Temperature: number;
}

export interface IMotorFault {
  ErrorFlags: IMotorErrorFlags | undefined;
  LimitFlags: IMotorLimitFlags | undefined;
  RxErrorCount: number;
  TxErrorCount: number;
}

export interface IMotorErrorFlags {
  BadMotorPositionHallSequence: boolean;
  ConfigReadError: boolean;
  DcBusOverVoltage: boolean;
  DesaturationFault: boolean;
  MotorOverSpeed: boolean;
  SoftwareOverCurrent: boolean;
  Wail15VUnderVoltageLockOut: boolean;
  WatchdogCausedLastReset: boolean;
}

export interface IMotorLimitFlags {
  BusCurrent: boolean;
  BusVoltageLower: boolean;
  BusVoltageUpper: boolean;
  IpmOrMotorTemperature: boolean;
  MotorCurrent: boolean;
  OutputVoltagePwm: boolean;
  Velocity: boolean;
}

export interface IBattery {
  InputVoltage: number;
  Alive: boolean;
  AverageCellVoltage: number;
  AverageTemperature: number;
  BMSRelayStatusFlags: IBMSRelayStatusFlags | undefined;
  FanSpeed: number;
  FanVoltage: number;
  HighCellVoltage: number;
  HighCellVoltageId: number;
  HighTemperature: number;
  HighThermistorId: number;
  InternalTemperature: number;
  LowCellVoltage: number;
  LowCellVoltageId: number;
  LowTemperature: number;
  LowThermistorId: number;
  PackAmphours: number;
  PackCurrent: number;
  PackDepthOfDischarge: number;
  PackStateOfCharge: number;
  PackVoltage: number;
  PopulatedCells: number;
  RequestedFanSpeed: number;
}

export interface IBMSRelayStatusFlags {
  AlwaysOnSignalStatus: boolean;
  ChargeRelayEnabled: boolean;
  ChargerSafetyEnabled: boolean;
  DischargeRelayEnabled: boolean;
  IsChargingSignalStatus: boolean;
  IsReadySignalStatus: boolean;
  MalfunctionIndicatorActive: boolean;
  MultiPurposeInputSignalStatus: boolean;
}

function createBaseCoordUpdateResponse(): CoordUpdateResponse {
  return { coords: undefined, error: undefined };
}

export const CoordUpdateResponse: MessageFns<CoordUpdateResponse> = {
  encode(message: CoordUpdateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.coords !== undefined) {
      Coords.encode(message.coords, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CoordUpdateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoordUpdateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.coords = Coords.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CoordUpdateResponse {
    return {
      coords: isSet(object.coords) ? Coords.fromJSON(object.coords) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: CoordUpdateResponse): unknown {
    const obj: any = {};
    if (message.coords !== undefined) {
      obj.coords = Coords.toJSON(message.coords);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CoordUpdateResponse>, I>>(base?: I): CoordUpdateResponse {
    return CoordUpdateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CoordUpdateResponse>, I>>(object: I): CoordUpdateResponse {
    const message = createBaseCoordUpdateResponse();
    message.coords = (object.coords !== undefined && object.coords !== null)
      ? Coords.fromPartial(object.coords)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseCoords(): Coords {
  return { lat: 0, long: 0 };
}

export const Coords: MessageFns<Coords> = {
  encode(message: Coords, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lat !== 0) {
      writer.uint32(9).double(message.lat);
    }
    if (message.long !== 0) {
      writer.uint32(17).double(message.long);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Coords {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoords();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.lat = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.long = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Coords {
    return {
      lat: isSet(object.lat) ? globalThis.Number(object.lat) : 0,
      long: isSet(object.long) ? globalThis.Number(object.long) : 0,
    };
  },

  toJSON(message: Coords): unknown {
    const obj: any = {};
    if (message.lat !== 0) {
      obj.lat = message.lat;
    }
    if (message.long !== 0) {
      obj.long = message.long;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Coords>, I>>(base?: I): Coords {
    return Coords.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Coords>, I>>(object: I): Coords {
    const message = createBaseCoords();
    message.lat = object.lat ?? 0;
    message.long = object.long ?? 0;
    return message;
  },
};

function createBaseError(): Error {
  return { error: "", invalidFields: [] };
}

export const Error: MessageFns<Error> = {
  encode(message: Error, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== "") {
      writer.uint32(10).string(message.error);
    }
    for (const v of message.invalidFields) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Error {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.invalidFields.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Error {
    return {
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      invalidFields: globalThis.Array.isArray(object?.invalidFields)
        ? object.invalidFields.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Error): unknown {
    const obj: any = {};
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.invalidFields?.length) {
      obj.invalidFields = message.invalidFields;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Error>, I>>(base?: I): Error {
    return Error.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Error>, I>>(object: I): Error {
    const message = createBaseError();
    message.error = object.error ?? "";
    message.invalidFields = object.invalidFields?.map((e) => e) || [];
    return message;
  },
};

function createBaseCoordInfoUpdate(): CoordInfoUpdate {
  return { lat: "", long: "", password: "" };
}

export const CoordInfoUpdate: MessageFns<CoordInfoUpdate> = {
  encode(message: CoordInfoUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lat !== "") {
      writer.uint32(10).string(message.lat);
    }
    if (message.long !== "") {
      writer.uint32(18).string(message.long);
    }
    if (message.password !== "") {
      writer.uint32(26).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CoordInfoUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoordInfoUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lat = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.long = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CoordInfoUpdate {
    return {
      lat: isSet(object.lat) ? globalThis.String(object.lat) : "",
      long: isSet(object.long) ? globalThis.String(object.long) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: CoordInfoUpdate): unknown {
    const obj: any = {};
    if (message.lat !== "") {
      obj.lat = message.lat;
    }
    if (message.long !== "") {
      obj.long = message.long;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CoordInfoUpdate>, I>>(base?: I): CoordInfoUpdate {
    return CoordInfoUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CoordInfoUpdate>, I>>(object: I): CoordInfoUpdate {
    const message = createBaseCoordInfoUpdate();
    message.lat = object.lat ?? "";
    message.long = object.long ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseITelemetryData(): ITelemetryData {
  return {
    AuxBms: undefined,
    Battery: undefined,
    BatteryFaults: undefined,
    Ccs: undefined,
    DriverControls: undefined,
    KeyMotor: [],
    Lights: undefined,
    MPPT: [],
    MotorDetails: [],
    MotorFaults: [],
    PacketTitle: "",
    TimeStamp: 0,
  };
}

export const ITelemetryData: MessageFns<ITelemetryData> = {
  encode(message: ITelemetryData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.AuxBms !== undefined) {
      IAuxBms.encode(message.AuxBms, writer.uint32(10).fork()).join();
    }
    if (message.Battery !== undefined) {
      IBattery.encode(message.Battery, writer.uint32(18).fork()).join();
    }
    if (message.BatteryFaults !== undefined) {
      IBatteryFault.encode(message.BatteryFaults, writer.uint32(26).fork()).join();
    }
    if (message.Ccs !== undefined) {
      ICcs.encode(message.Ccs, writer.uint32(34).fork()).join();
    }
    if (message.DriverControls !== undefined) {
      IDriverControls.encode(message.DriverControls, writer.uint32(42).fork()).join();
    }
    for (const v of message.KeyMotor) {
      IKeyMotor.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.Lights !== undefined) {
      ILights.encode(message.Lights, writer.uint32(58).fork()).join();
    }
    for (const v of message.MPPT) {
      IMPPT.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.MotorDetails) {
      IMotorDetail.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.MotorFaults) {
      IMotorFault.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.PacketTitle !== "") {
      writer.uint32(90).string(message.PacketTitle);
    }
    if (message.TimeStamp !== 0) {
      writer.uint32(96).int64(message.TimeStamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ITelemetryData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseITelemetryData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.AuxBms = IAuxBms.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.Battery = IBattery.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.BatteryFaults = IBatteryFault.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.Ccs = ICcs.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.DriverControls = IDriverControls.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.KeyMotor.push(IKeyMotor.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.Lights = ILights.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.MPPT.push(IMPPT.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.MotorDetails.push(IMotorDetail.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.MotorFaults.push(IMotorFault.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.PacketTitle = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.TimeStamp = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ITelemetryData {
    return {
      AuxBms: isSet(object.AuxBms) ? IAuxBms.fromJSON(object.AuxBms) : undefined,
      Battery: isSet(object.Battery) ? IBattery.fromJSON(object.Battery) : undefined,
      BatteryFaults: isSet(object.BatteryFaults) ? IBatteryFault.fromJSON(object.BatteryFaults) : undefined,
      Ccs: isSet(object.Ccs) ? ICcs.fromJSON(object.Ccs) : undefined,
      DriverControls: isSet(object.DriverControls) ? IDriverControls.fromJSON(object.DriverControls) : undefined,
      KeyMotor: globalThis.Array.isArray(object?.KeyMotor)
        ? object.KeyMotor.map((e: any) => IKeyMotor.fromJSON(e))
        : [],
      Lights: isSet(object.Lights) ? ILights.fromJSON(object.Lights) : undefined,
      MPPT: globalThis.Array.isArray(object?.MPPT) ? object.MPPT.map((e: any) => IMPPT.fromJSON(e)) : [],
      MotorDetails: globalThis.Array.isArray(object?.MotorDetails)
        ? object.MotorDetails.map((e: any) => IMotorDetail.fromJSON(e))
        : [],
      MotorFaults: globalThis.Array.isArray(object?.MotorFaults)
        ? object.MotorFaults.map((e: any) => IMotorFault.fromJSON(e))
        : [],
      PacketTitle: isSet(object.PacketTitle) ? globalThis.String(object.PacketTitle) : "",
      TimeStamp: isSet(object.TimeStamp) ? globalThis.Number(object.TimeStamp) : 0,
    };
  },

  toJSON(message: ITelemetryData): unknown {
    const obj: any = {};
    if (message.AuxBms !== undefined) {
      obj.AuxBms = IAuxBms.toJSON(message.AuxBms);
    }
    if (message.Battery !== undefined) {
      obj.Battery = IBattery.toJSON(message.Battery);
    }
    if (message.BatteryFaults !== undefined) {
      obj.BatteryFaults = IBatteryFault.toJSON(message.BatteryFaults);
    }
    if (message.Ccs !== undefined) {
      obj.Ccs = ICcs.toJSON(message.Ccs);
    }
    if (message.DriverControls !== undefined) {
      obj.DriverControls = IDriverControls.toJSON(message.DriverControls);
    }
    if (message.KeyMotor?.length) {
      obj.KeyMotor = message.KeyMotor.map((e) => IKeyMotor.toJSON(e));
    }
    if (message.Lights !== undefined) {
      obj.Lights = ILights.toJSON(message.Lights);
    }
    if (message.MPPT?.length) {
      obj.MPPT = message.MPPT.map((e) => IMPPT.toJSON(e));
    }
    if (message.MotorDetails?.length) {
      obj.MotorDetails = message.MotorDetails.map((e) => IMotorDetail.toJSON(e));
    }
    if (message.MotorFaults?.length) {
      obj.MotorFaults = message.MotorFaults.map((e) => IMotorFault.toJSON(e));
    }
    if (message.PacketTitle !== "") {
      obj.PacketTitle = message.PacketTitle;
    }
    if (message.TimeStamp !== 0) {
      obj.TimeStamp = Math.round(message.TimeStamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ITelemetryData>, I>>(base?: I): ITelemetryData {
    return ITelemetryData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ITelemetryData>, I>>(object: I): ITelemetryData {
    const message = createBaseITelemetryData();
    message.AuxBms = (object.AuxBms !== undefined && object.AuxBms !== null)
      ? IAuxBms.fromPartial(object.AuxBms)
      : undefined;
    message.Battery = (object.Battery !== undefined && object.Battery !== null)
      ? IBattery.fromPartial(object.Battery)
      : undefined;
    message.BatteryFaults = (object.BatteryFaults !== undefined && object.BatteryFaults !== null)
      ? IBatteryFault.fromPartial(object.BatteryFaults)
      : undefined;
    message.Ccs = (object.Ccs !== undefined && object.Ccs !== null) ? ICcs.fromPartial(object.Ccs) : undefined;
    message.DriverControls = (object.DriverControls !== undefined && object.DriverControls !== null)
      ? IDriverControls.fromPartial(object.DriverControls)
      : undefined;
    message.KeyMotor = object.KeyMotor?.map((e) => IKeyMotor.fromPartial(e)) || [];
    message.Lights = (object.Lights !== undefined && object.Lights !== null)
      ? ILights.fromPartial(object.Lights)
      : undefined;
    message.MPPT = object.MPPT?.map((e) => IMPPT.fromPartial(e)) || [];
    message.MotorDetails = object.MotorDetails?.map((e) => IMotorDetail.fromPartial(e)) || [];
    message.MotorFaults = object.MotorFaults?.map((e) => IMotorFault.fromPartial(e)) || [];
    message.PacketTitle = object.PacketTitle ?? "";
    message.TimeStamp = object.TimeStamp ?? 0;
    return message;
  },
};

function createBaseILapData(): ILapData {
  return {
    ampHours: 0,
    averagePackCurrent: 0,
    averageSpeed: 0,
    batterySecondsRemaining: 0,
    distance: 0,
    lapTime: 0,
    netPowerOut: 0,
    timeStamp: 0,
    totalPowerIn: 0,
    totalPowerOut: 0,
  };
}

export const ILapData: MessageFns<ILapData> = {
  encode(message: ILapData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ampHours !== 0) {
      writer.uint32(9).double(message.ampHours);
    }
    if (message.averagePackCurrent !== 0) {
      writer.uint32(17).double(message.averagePackCurrent);
    }
    if (message.averageSpeed !== 0) {
      writer.uint32(25).double(message.averageSpeed);
    }
    if (message.batterySecondsRemaining !== 0) {
      writer.uint32(33).double(message.batterySecondsRemaining);
    }
    if (message.distance !== 0) {
      writer.uint32(41).double(message.distance);
    }
    if (message.lapTime !== 0) {
      writer.uint32(49).double(message.lapTime);
    }
    if (message.netPowerOut !== 0) {
      writer.uint32(57).double(message.netPowerOut);
    }
    if (message.timeStamp !== 0) {
      writer.uint32(64).int64(message.timeStamp);
    }
    if (message.totalPowerIn !== 0) {
      writer.uint32(73).double(message.totalPowerIn);
    }
    if (message.totalPowerOut !== 0) {
      writer.uint32(81).double(message.totalPowerOut);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ILapData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseILapData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.ampHours = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.averagePackCurrent = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.averageSpeed = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.batterySecondsRemaining = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.distance = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.lapTime = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.netPowerOut = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.timeStamp = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 73) {
            break;
          }

          message.totalPowerIn = reader.double();
          continue;
        }
        case 10: {
          if (tag !== 81) {
            break;
          }

          message.totalPowerOut = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ILapData {
    return {
      ampHours: isSet(object.ampHours) ? globalThis.Number(object.ampHours) : 0,
      averagePackCurrent: isSet(object.averagePackCurrent) ? globalThis.Number(object.averagePackCurrent) : 0,
      averageSpeed: isSet(object.averageSpeed) ? globalThis.Number(object.averageSpeed) : 0,
      batterySecondsRemaining: isSet(object.batterySecondsRemaining)
        ? globalThis.Number(object.batterySecondsRemaining)
        : 0,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : 0,
      lapTime: isSet(object.lapTime) ? globalThis.Number(object.lapTime) : 0,
      netPowerOut: isSet(object.netPowerOut) ? globalThis.Number(object.netPowerOut) : 0,
      timeStamp: isSet(object.timeStamp) ? globalThis.Number(object.timeStamp) : 0,
      totalPowerIn: isSet(object.totalPowerIn) ? globalThis.Number(object.totalPowerIn) : 0,
      totalPowerOut: isSet(object.totalPowerOut) ? globalThis.Number(object.totalPowerOut) : 0,
    };
  },

  toJSON(message: ILapData): unknown {
    const obj: any = {};
    if (message.ampHours !== 0) {
      obj.ampHours = message.ampHours;
    }
    if (message.averagePackCurrent !== 0) {
      obj.averagePackCurrent = message.averagePackCurrent;
    }
    if (message.averageSpeed !== 0) {
      obj.averageSpeed = message.averageSpeed;
    }
    if (message.batterySecondsRemaining !== 0) {
      obj.batterySecondsRemaining = message.batterySecondsRemaining;
    }
    if (message.distance !== 0) {
      obj.distance = message.distance;
    }
    if (message.lapTime !== 0) {
      obj.lapTime = message.lapTime;
    }
    if (message.netPowerOut !== 0) {
      obj.netPowerOut = message.netPowerOut;
    }
    if (message.timeStamp !== 0) {
      obj.timeStamp = Math.round(message.timeStamp);
    }
    if (message.totalPowerIn !== 0) {
      obj.totalPowerIn = message.totalPowerIn;
    }
    if (message.totalPowerOut !== 0) {
      obj.totalPowerOut = message.totalPowerOut;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ILapData>, I>>(base?: I): ILapData {
    return ILapData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ILapData>, I>>(object: I): ILapData {
    const message = createBaseILapData();
    message.ampHours = object.ampHours ?? 0;
    message.averagePackCurrent = object.averagePackCurrent ?? 0;
    message.averageSpeed = object.averageSpeed ?? 0;
    message.batterySecondsRemaining = object.batterySecondsRemaining ?? 0;
    message.distance = object.distance ?? 0;
    message.lapTime = object.lapTime ?? 0;
    message.netPowerOut = object.netPowerOut ?? 0;
    message.timeStamp = object.timeStamp ?? 0;
    message.totalPowerIn = object.totalPowerIn ?? 0;
    message.totalPowerOut = object.totalPowerOut ?? 0;
    return message;
  },
};

function createBaseIAuxBms(): IAuxBms {
  return {
    AllowCharge: false,
    AllowDischarge: false,
    AuxBmsAlive: false,
    AuxVoltage: 0,
    ChargeContactorError: false,
    ChargeNotClosedDueToHighCurrent: false,
    ChargeOpenButShouldBeClosed: false,
    ChargeShouldTrip: false,
    ChargeTripDueToHighCellVoltage: false,
    ChargeTripDueToHighTemperatureAndCurrent: false,
    ChargeTripDueToPackCurrent: false,
    CommonContactorError: false,
    DischargeContactorError: false,
    DischargeNotClosedDueToHighCurrent: false,
    DischargeOpenButShouldBeClosed: false,
    DischargeShouldTrip: false,
    DischargeTripDueToHighTemperatureAndCurrent: false,
    DischargeTripDueToLowCellVoltage: false,
    DischargeTripDueToPackCurrent: false,
    HighVoltageEnableState: false,
    OrionCANReceivedRecently: false,
    PrechargeState: "",
    ProtectionTrip: false,
    StrobeBmsLight: false,
    TripDueToOrionMessageTimeout: false,
  };
}

export const IAuxBms: MessageFns<IAuxBms> = {
  encode(message: IAuxBms, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.AllowCharge !== false) {
      writer.uint32(8).bool(message.AllowCharge);
    }
    if (message.AllowDischarge !== false) {
      writer.uint32(16).bool(message.AllowDischarge);
    }
    if (message.AuxBmsAlive !== false) {
      writer.uint32(24).bool(message.AuxBmsAlive);
    }
    if (message.AuxVoltage !== 0) {
      writer.uint32(33).double(message.AuxVoltage);
    }
    if (message.ChargeContactorError !== false) {
      writer.uint32(40).bool(message.ChargeContactorError);
    }
    if (message.ChargeNotClosedDueToHighCurrent !== false) {
      writer.uint32(48).bool(message.ChargeNotClosedDueToHighCurrent);
    }
    if (message.ChargeOpenButShouldBeClosed !== false) {
      writer.uint32(56).bool(message.ChargeOpenButShouldBeClosed);
    }
    if (message.ChargeShouldTrip !== false) {
      writer.uint32(64).bool(message.ChargeShouldTrip);
    }
    if (message.ChargeTripDueToHighCellVoltage !== false) {
      writer.uint32(72).bool(message.ChargeTripDueToHighCellVoltage);
    }
    if (message.ChargeTripDueToHighTemperatureAndCurrent !== false) {
      writer.uint32(80).bool(message.ChargeTripDueToHighTemperatureAndCurrent);
    }
    if (message.ChargeTripDueToPackCurrent !== false) {
      writer.uint32(88).bool(message.ChargeTripDueToPackCurrent);
    }
    if (message.CommonContactorError !== false) {
      writer.uint32(96).bool(message.CommonContactorError);
    }
    if (message.DischargeContactorError !== false) {
      writer.uint32(104).bool(message.DischargeContactorError);
    }
    if (message.DischargeNotClosedDueToHighCurrent !== false) {
      writer.uint32(112).bool(message.DischargeNotClosedDueToHighCurrent);
    }
    if (message.DischargeOpenButShouldBeClosed !== false) {
      writer.uint32(120).bool(message.DischargeOpenButShouldBeClosed);
    }
    if (message.DischargeShouldTrip !== false) {
      writer.uint32(128).bool(message.DischargeShouldTrip);
    }
    if (message.DischargeTripDueToHighTemperatureAndCurrent !== false) {
      writer.uint32(136).bool(message.DischargeTripDueToHighTemperatureAndCurrent);
    }
    if (message.DischargeTripDueToLowCellVoltage !== false) {
      writer.uint32(144).bool(message.DischargeTripDueToLowCellVoltage);
    }
    if (message.DischargeTripDueToPackCurrent !== false) {
      writer.uint32(152).bool(message.DischargeTripDueToPackCurrent);
    }
    if (message.HighVoltageEnableState !== false) {
      writer.uint32(160).bool(message.HighVoltageEnableState);
    }
    if (message.OrionCANReceivedRecently !== false) {
      writer.uint32(168).bool(message.OrionCANReceivedRecently);
    }
    if (message.PrechargeState !== "") {
      writer.uint32(178).string(message.PrechargeState);
    }
    if (message.ProtectionTrip !== false) {
      writer.uint32(184).bool(message.ProtectionTrip);
    }
    if (message.StrobeBmsLight !== false) {
      writer.uint32(192).bool(message.StrobeBmsLight);
    }
    if (message.TripDueToOrionMessageTimeout !== false) {
      writer.uint32(200).bool(message.TripDueToOrionMessageTimeout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IAuxBms {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIAuxBms();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.AllowCharge = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.AllowDischarge = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.AuxBmsAlive = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.AuxVoltage = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.ChargeContactorError = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.ChargeNotClosedDueToHighCurrent = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.ChargeOpenButShouldBeClosed = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.ChargeShouldTrip = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.ChargeTripDueToHighCellVoltage = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.ChargeTripDueToHighTemperatureAndCurrent = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.ChargeTripDueToPackCurrent = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.CommonContactorError = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.DischargeContactorError = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.DischargeNotClosedDueToHighCurrent = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.DischargeOpenButShouldBeClosed = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.DischargeShouldTrip = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.DischargeTripDueToHighTemperatureAndCurrent = reader.bool();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.DischargeTripDueToLowCellVoltage = reader.bool();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.DischargeTripDueToPackCurrent = reader.bool();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.HighVoltageEnableState = reader.bool();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.OrionCANReceivedRecently = reader.bool();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.PrechargeState = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.ProtectionTrip = reader.bool();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.StrobeBmsLight = reader.bool();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.TripDueToOrionMessageTimeout = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IAuxBms {
    return {
      AllowCharge: isSet(object.AllowCharge) ? globalThis.Boolean(object.AllowCharge) : false,
      AllowDischarge: isSet(object.AllowDischarge) ? globalThis.Boolean(object.AllowDischarge) : false,
      AuxBmsAlive: isSet(object.AuxBmsAlive) ? globalThis.Boolean(object.AuxBmsAlive) : false,
      AuxVoltage: isSet(object.AuxVoltage) ? globalThis.Number(object.AuxVoltage) : 0,
      ChargeContactorError: isSet(object.ChargeContactorError)
        ? globalThis.Boolean(object.ChargeContactorError)
        : false,
      ChargeNotClosedDueToHighCurrent: isSet(object.ChargeNotClosedDueToHighCurrent)
        ? globalThis.Boolean(object.ChargeNotClosedDueToHighCurrent)
        : false,
      ChargeOpenButShouldBeClosed: isSet(object.ChargeOpenButShouldBeClosed)
        ? globalThis.Boolean(object.ChargeOpenButShouldBeClosed)
        : false,
      ChargeShouldTrip: isSet(object.ChargeShouldTrip) ? globalThis.Boolean(object.ChargeShouldTrip) : false,
      ChargeTripDueToHighCellVoltage: isSet(object.ChargeTripDueToHighCellVoltage)
        ? globalThis.Boolean(object.ChargeTripDueToHighCellVoltage)
        : false,
      ChargeTripDueToHighTemperatureAndCurrent: isSet(object.ChargeTripDueToHighTemperatureAndCurrent)
        ? globalThis.Boolean(object.ChargeTripDueToHighTemperatureAndCurrent)
        : false,
      ChargeTripDueToPackCurrent: isSet(object.ChargeTripDueToPackCurrent)
        ? globalThis.Boolean(object.ChargeTripDueToPackCurrent)
        : false,
      CommonContactorError: isSet(object.CommonContactorError)
        ? globalThis.Boolean(object.CommonContactorError)
        : false,
      DischargeContactorError: isSet(object.DischargeContactorError)
        ? globalThis.Boolean(object.DischargeContactorError)
        : false,
      DischargeNotClosedDueToHighCurrent: isSet(object.DischargeNotClosedDueToHighCurrent)
        ? globalThis.Boolean(object.DischargeNotClosedDueToHighCurrent)
        : false,
      DischargeOpenButShouldBeClosed: isSet(object.DischargeOpenButShouldBeClosed)
        ? globalThis.Boolean(object.DischargeOpenButShouldBeClosed)
        : false,
      DischargeShouldTrip: isSet(object.DischargeShouldTrip) ? globalThis.Boolean(object.DischargeShouldTrip) : false,
      DischargeTripDueToHighTemperatureAndCurrent: isSet(object.DischargeTripDueToHighTemperatureAndCurrent)
        ? globalThis.Boolean(object.DischargeTripDueToHighTemperatureAndCurrent)
        : false,
      DischargeTripDueToLowCellVoltage: isSet(object.DischargeTripDueToLowCellVoltage)
        ? globalThis.Boolean(object.DischargeTripDueToLowCellVoltage)
        : false,
      DischargeTripDueToPackCurrent: isSet(object.DischargeTripDueToPackCurrent)
        ? globalThis.Boolean(object.DischargeTripDueToPackCurrent)
        : false,
      HighVoltageEnableState: isSet(object.HighVoltageEnableState)
        ? globalThis.Boolean(object.HighVoltageEnableState)
        : false,
      OrionCANReceivedRecently: isSet(object.OrionCANReceivedRecently)
        ? globalThis.Boolean(object.OrionCANReceivedRecently)
        : false,
      PrechargeState: isSet(object.PrechargeState) ? globalThis.String(object.PrechargeState) : "",
      ProtectionTrip: isSet(object.ProtectionTrip) ? globalThis.Boolean(object.ProtectionTrip) : false,
      StrobeBmsLight: isSet(object.StrobeBmsLight) ? globalThis.Boolean(object.StrobeBmsLight) : false,
      TripDueToOrionMessageTimeout: isSet(object.TripDueToOrionMessageTimeout)
        ? globalThis.Boolean(object.TripDueToOrionMessageTimeout)
        : false,
    };
  },

  toJSON(message: IAuxBms): unknown {
    const obj: any = {};
    if (message.AllowCharge !== false) {
      obj.AllowCharge = message.AllowCharge;
    }
    if (message.AllowDischarge !== false) {
      obj.AllowDischarge = message.AllowDischarge;
    }
    if (message.AuxBmsAlive !== false) {
      obj.AuxBmsAlive = message.AuxBmsAlive;
    }
    if (message.AuxVoltage !== 0) {
      obj.AuxVoltage = message.AuxVoltage;
    }
    if (message.ChargeContactorError !== false) {
      obj.ChargeContactorError = message.ChargeContactorError;
    }
    if (message.ChargeNotClosedDueToHighCurrent !== false) {
      obj.ChargeNotClosedDueToHighCurrent = message.ChargeNotClosedDueToHighCurrent;
    }
    if (message.ChargeOpenButShouldBeClosed !== false) {
      obj.ChargeOpenButShouldBeClosed = message.ChargeOpenButShouldBeClosed;
    }
    if (message.ChargeShouldTrip !== false) {
      obj.ChargeShouldTrip = message.ChargeShouldTrip;
    }
    if (message.ChargeTripDueToHighCellVoltage !== false) {
      obj.ChargeTripDueToHighCellVoltage = message.ChargeTripDueToHighCellVoltage;
    }
    if (message.ChargeTripDueToHighTemperatureAndCurrent !== false) {
      obj.ChargeTripDueToHighTemperatureAndCurrent = message.ChargeTripDueToHighTemperatureAndCurrent;
    }
    if (message.ChargeTripDueToPackCurrent !== false) {
      obj.ChargeTripDueToPackCurrent = message.ChargeTripDueToPackCurrent;
    }
    if (message.CommonContactorError !== false) {
      obj.CommonContactorError = message.CommonContactorError;
    }
    if (message.DischargeContactorError !== false) {
      obj.DischargeContactorError = message.DischargeContactorError;
    }
    if (message.DischargeNotClosedDueToHighCurrent !== false) {
      obj.DischargeNotClosedDueToHighCurrent = message.DischargeNotClosedDueToHighCurrent;
    }
    if (message.DischargeOpenButShouldBeClosed !== false) {
      obj.DischargeOpenButShouldBeClosed = message.DischargeOpenButShouldBeClosed;
    }
    if (message.DischargeShouldTrip !== false) {
      obj.DischargeShouldTrip = message.DischargeShouldTrip;
    }
    if (message.DischargeTripDueToHighTemperatureAndCurrent !== false) {
      obj.DischargeTripDueToHighTemperatureAndCurrent = message.DischargeTripDueToHighTemperatureAndCurrent;
    }
    if (message.DischargeTripDueToLowCellVoltage !== false) {
      obj.DischargeTripDueToLowCellVoltage = message.DischargeTripDueToLowCellVoltage;
    }
    if (message.DischargeTripDueToPackCurrent !== false) {
      obj.DischargeTripDueToPackCurrent = message.DischargeTripDueToPackCurrent;
    }
    if (message.HighVoltageEnableState !== false) {
      obj.HighVoltageEnableState = message.HighVoltageEnableState;
    }
    if (message.OrionCANReceivedRecently !== false) {
      obj.OrionCANReceivedRecently = message.OrionCANReceivedRecently;
    }
    if (message.PrechargeState !== "") {
      obj.PrechargeState = message.PrechargeState;
    }
    if (message.ProtectionTrip !== false) {
      obj.ProtectionTrip = message.ProtectionTrip;
    }
    if (message.StrobeBmsLight !== false) {
      obj.StrobeBmsLight = message.StrobeBmsLight;
    }
    if (message.TripDueToOrionMessageTimeout !== false) {
      obj.TripDueToOrionMessageTimeout = message.TripDueToOrionMessageTimeout;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IAuxBms>, I>>(base?: I): IAuxBms {
    return IAuxBms.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IAuxBms>, I>>(object: I): IAuxBms {
    const message = createBaseIAuxBms();
    message.AllowCharge = object.AllowCharge ?? false;
    message.AllowDischarge = object.AllowDischarge ?? false;
    message.AuxBmsAlive = object.AuxBmsAlive ?? false;
    message.AuxVoltage = object.AuxVoltage ?? 0;
    message.ChargeContactorError = object.ChargeContactorError ?? false;
    message.ChargeNotClosedDueToHighCurrent = object.ChargeNotClosedDueToHighCurrent ?? false;
    message.ChargeOpenButShouldBeClosed = object.ChargeOpenButShouldBeClosed ?? false;
    message.ChargeShouldTrip = object.ChargeShouldTrip ?? false;
    message.ChargeTripDueToHighCellVoltage = object.ChargeTripDueToHighCellVoltage ?? false;
    message.ChargeTripDueToHighTemperatureAndCurrent = object.ChargeTripDueToHighTemperatureAndCurrent ?? false;
    message.ChargeTripDueToPackCurrent = object.ChargeTripDueToPackCurrent ?? false;
    message.CommonContactorError = object.CommonContactorError ?? false;
    message.DischargeContactorError = object.DischargeContactorError ?? false;
    message.DischargeNotClosedDueToHighCurrent = object.DischargeNotClosedDueToHighCurrent ?? false;
    message.DischargeOpenButShouldBeClosed = object.DischargeOpenButShouldBeClosed ?? false;
    message.DischargeShouldTrip = object.DischargeShouldTrip ?? false;
    message.DischargeTripDueToHighTemperatureAndCurrent = object.DischargeTripDueToHighTemperatureAndCurrent ?? false;
    message.DischargeTripDueToLowCellVoltage = object.DischargeTripDueToLowCellVoltage ?? false;
    message.DischargeTripDueToPackCurrent = object.DischargeTripDueToPackCurrent ?? false;
    message.HighVoltageEnableState = object.HighVoltageEnableState ?? false;
    message.OrionCANReceivedRecently = object.OrionCANReceivedRecently ?? false;
    message.PrechargeState = object.PrechargeState ?? "";
    message.ProtectionTrip = object.ProtectionTrip ?? false;
    message.StrobeBmsLight = object.StrobeBmsLight ?? false;
    message.TripDueToOrionMessageTimeout = object.TripDueToOrionMessageTimeout ?? false;
    return message;
  },
};

function createBaseIKeyMotor(): IKeyMotor {
  return { Alive: false, BusCurrent: 0, BusVoltage: 0, SetCurrent: 0, SetVelocity: 0, VehicleVelocity: 0 };
}

export const IKeyMotor: MessageFns<IKeyMotor> = {
  encode(message: IKeyMotor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Alive !== false) {
      writer.uint32(8).bool(message.Alive);
    }
    if (message.BusCurrent !== 0) {
      writer.uint32(17).double(message.BusCurrent);
    }
    if (message.BusVoltage !== 0) {
      writer.uint32(25).double(message.BusVoltage);
    }
    if (message.SetCurrent !== 0) {
      writer.uint32(33).double(message.SetCurrent);
    }
    if (message.SetVelocity !== 0) {
      writer.uint32(41).double(message.SetVelocity);
    }
    if (message.VehicleVelocity !== 0) {
      writer.uint32(49).double(message.VehicleVelocity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IKeyMotor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIKeyMotor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.Alive = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.BusCurrent = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.BusVoltage = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.SetCurrent = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.SetVelocity = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.VehicleVelocity = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IKeyMotor {
    return {
      Alive: isSet(object.Alive) ? globalThis.Boolean(object.Alive) : false,
      BusCurrent: isSet(object.BusCurrent) ? globalThis.Number(object.BusCurrent) : 0,
      BusVoltage: isSet(object.BusVoltage) ? globalThis.Number(object.BusVoltage) : 0,
      SetCurrent: isSet(object.SetCurrent) ? globalThis.Number(object.SetCurrent) : 0,
      SetVelocity: isSet(object.SetVelocity) ? globalThis.Number(object.SetVelocity) : 0,
      VehicleVelocity: isSet(object.VehicleVelocity) ? globalThis.Number(object.VehicleVelocity) : 0,
    };
  },

  toJSON(message: IKeyMotor): unknown {
    const obj: any = {};
    if (message.Alive !== false) {
      obj.Alive = message.Alive;
    }
    if (message.BusCurrent !== 0) {
      obj.BusCurrent = message.BusCurrent;
    }
    if (message.BusVoltage !== 0) {
      obj.BusVoltage = message.BusVoltage;
    }
    if (message.SetCurrent !== 0) {
      obj.SetCurrent = message.SetCurrent;
    }
    if (message.SetVelocity !== 0) {
      obj.SetVelocity = message.SetVelocity;
    }
    if (message.VehicleVelocity !== 0) {
      obj.VehicleVelocity = message.VehicleVelocity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IKeyMotor>, I>>(base?: I): IKeyMotor {
    return IKeyMotor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IKeyMotor>, I>>(object: I): IKeyMotor {
    const message = createBaseIKeyMotor();
    message.Alive = object.Alive ?? false;
    message.BusCurrent = object.BusCurrent ?? 0;
    message.BusVoltage = object.BusVoltage ?? 0;
    message.SetCurrent = object.SetCurrent ?? 0;
    message.SetVelocity = object.SetVelocity ?? 0;
    message.VehicleVelocity = object.VehicleVelocity ?? 0;
    return message;
  },
};

function createBaseIMotorDetail(): IMotorDetail {
  return {
    BackEmf: 0,
    DcBusAmpHours: 0,
    DspBoardTemp: 0,
    HeatSinkTemp: 0,
    MotorCurrentImaginary: 0,
    MotorCurrentReal: 0,
    MotorTemp: 0,
    MotorVoltageImaginary: 0,
    MotorVoltageReal: 0,
    Odometer: 0,
    PhaseBCurrent: 0,
    PhaseCCurrent: 0,
    SlipSpeed: 0,
    VoltageRail15VSupply: 0,
    VoltageRail1VSupply: 0,
    VoltageRail3VSupply: 0,
  };
}

export const IMotorDetail: MessageFns<IMotorDetail> = {
  encode(message: IMotorDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.BackEmf !== 0) {
      writer.uint32(9).double(message.BackEmf);
    }
    if (message.DcBusAmpHours !== 0) {
      writer.uint32(17).double(message.DcBusAmpHours);
    }
    if (message.DspBoardTemp !== 0) {
      writer.uint32(25).double(message.DspBoardTemp);
    }
    if (message.HeatSinkTemp !== 0) {
      writer.uint32(33).double(message.HeatSinkTemp);
    }
    if (message.MotorCurrentImaginary !== 0) {
      writer.uint32(41).double(message.MotorCurrentImaginary);
    }
    if (message.MotorCurrentReal !== 0) {
      writer.uint32(49).double(message.MotorCurrentReal);
    }
    if (message.MotorTemp !== 0) {
      writer.uint32(57).double(message.MotorTemp);
    }
    if (message.MotorVoltageImaginary !== 0) {
      writer.uint32(65).double(message.MotorVoltageImaginary);
    }
    if (message.MotorVoltageReal !== 0) {
      writer.uint32(73).double(message.MotorVoltageReal);
    }
    if (message.Odometer !== 0) {
      writer.uint32(81).double(message.Odometer);
    }
    if (message.PhaseBCurrent !== 0) {
      writer.uint32(89).double(message.PhaseBCurrent);
    }
    if (message.PhaseCCurrent !== 0) {
      writer.uint32(97).double(message.PhaseCCurrent);
    }
    if (message.SlipSpeed !== 0) {
      writer.uint32(105).double(message.SlipSpeed);
    }
    if (message.VoltageRail15VSupply !== 0) {
      writer.uint32(113).double(message.VoltageRail15VSupply);
    }
    if (message.VoltageRail1VSupply !== 0) {
      writer.uint32(121).double(message.VoltageRail1VSupply);
    }
    if (message.VoltageRail3VSupply !== 0) {
      writer.uint32(129).double(message.VoltageRail3VSupply);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IMotorDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIMotorDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.BackEmf = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.DcBusAmpHours = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.DspBoardTemp = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.HeatSinkTemp = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.MotorCurrentImaginary = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.MotorCurrentReal = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.MotorTemp = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 65) {
            break;
          }

          message.MotorVoltageImaginary = reader.double();
          continue;
        }
        case 9: {
          if (tag !== 73) {
            break;
          }

          message.MotorVoltageReal = reader.double();
          continue;
        }
        case 10: {
          if (tag !== 81) {
            break;
          }

          message.Odometer = reader.double();
          continue;
        }
        case 11: {
          if (tag !== 89) {
            break;
          }

          message.PhaseBCurrent = reader.double();
          continue;
        }
        case 12: {
          if (tag !== 97) {
            break;
          }

          message.PhaseCCurrent = reader.double();
          continue;
        }
        case 13: {
          if (tag !== 105) {
            break;
          }

          message.SlipSpeed = reader.double();
          continue;
        }
        case 14: {
          if (tag !== 113) {
            break;
          }

          message.VoltageRail15VSupply = reader.double();
          continue;
        }
        case 15: {
          if (tag !== 121) {
            break;
          }

          message.VoltageRail1VSupply = reader.double();
          continue;
        }
        case 16: {
          if (tag !== 129) {
            break;
          }

          message.VoltageRail3VSupply = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IMotorDetail {
    return {
      BackEmf: isSet(object.BackEmf) ? globalThis.Number(object.BackEmf) : 0,
      DcBusAmpHours: isSet(object.DcBusAmpHours) ? globalThis.Number(object.DcBusAmpHours) : 0,
      DspBoardTemp: isSet(object.DspBoardTemp) ? globalThis.Number(object.DspBoardTemp) : 0,
      HeatSinkTemp: isSet(object.HeatSinkTemp) ? globalThis.Number(object.HeatSinkTemp) : 0,
      MotorCurrentImaginary: isSet(object.MotorCurrentImaginary) ? globalThis.Number(object.MotorCurrentImaginary) : 0,
      MotorCurrentReal: isSet(object.MotorCurrentReal) ? globalThis.Number(object.MotorCurrentReal) : 0,
      MotorTemp: isSet(object.MotorTemp) ? globalThis.Number(object.MotorTemp) : 0,
      MotorVoltageImaginary: isSet(object.MotorVoltageImaginary) ? globalThis.Number(object.MotorVoltageImaginary) : 0,
      MotorVoltageReal: isSet(object.MotorVoltageReal) ? globalThis.Number(object.MotorVoltageReal) : 0,
      Odometer: isSet(object.Odometer) ? globalThis.Number(object.Odometer) : 0,
      PhaseBCurrent: isSet(object.PhaseBCurrent) ? globalThis.Number(object.PhaseBCurrent) : 0,
      PhaseCCurrent: isSet(object.PhaseCCurrent) ? globalThis.Number(object.PhaseCCurrent) : 0,
      SlipSpeed: isSet(object.SlipSpeed) ? globalThis.Number(object.SlipSpeed) : 0,
      VoltageRail15VSupply: isSet(object.VoltageRail15VSupply) ? globalThis.Number(object.VoltageRail15VSupply) : 0,
      VoltageRail1VSupply: isSet(object.VoltageRail1VSupply) ? globalThis.Number(object.VoltageRail1VSupply) : 0,
      VoltageRail3VSupply: isSet(object.VoltageRail3VSupply) ? globalThis.Number(object.VoltageRail3VSupply) : 0,
    };
  },

  toJSON(message: IMotorDetail): unknown {
    const obj: any = {};
    if (message.BackEmf !== 0) {
      obj.BackEmf = message.BackEmf;
    }
    if (message.DcBusAmpHours !== 0) {
      obj.DcBusAmpHours = message.DcBusAmpHours;
    }
    if (message.DspBoardTemp !== 0) {
      obj.DspBoardTemp = message.DspBoardTemp;
    }
    if (message.HeatSinkTemp !== 0) {
      obj.HeatSinkTemp = message.HeatSinkTemp;
    }
    if (message.MotorCurrentImaginary !== 0) {
      obj.MotorCurrentImaginary = message.MotorCurrentImaginary;
    }
    if (message.MotorCurrentReal !== 0) {
      obj.MotorCurrentReal = message.MotorCurrentReal;
    }
    if (message.MotorTemp !== 0) {
      obj.MotorTemp = message.MotorTemp;
    }
    if (message.MotorVoltageImaginary !== 0) {
      obj.MotorVoltageImaginary = message.MotorVoltageImaginary;
    }
    if (message.MotorVoltageReal !== 0) {
      obj.MotorVoltageReal = message.MotorVoltageReal;
    }
    if (message.Odometer !== 0) {
      obj.Odometer = message.Odometer;
    }
    if (message.PhaseBCurrent !== 0) {
      obj.PhaseBCurrent = message.PhaseBCurrent;
    }
    if (message.PhaseCCurrent !== 0) {
      obj.PhaseCCurrent = message.PhaseCCurrent;
    }
    if (message.SlipSpeed !== 0) {
      obj.SlipSpeed = message.SlipSpeed;
    }
    if (message.VoltageRail15VSupply !== 0) {
      obj.VoltageRail15VSupply = message.VoltageRail15VSupply;
    }
    if (message.VoltageRail1VSupply !== 0) {
      obj.VoltageRail1VSupply = message.VoltageRail1VSupply;
    }
    if (message.VoltageRail3VSupply !== 0) {
      obj.VoltageRail3VSupply = message.VoltageRail3VSupply;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IMotorDetail>, I>>(base?: I): IMotorDetail {
    return IMotorDetail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IMotorDetail>, I>>(object: I): IMotorDetail {
    const message = createBaseIMotorDetail();
    message.BackEmf = object.BackEmf ?? 0;
    message.DcBusAmpHours = object.DcBusAmpHours ?? 0;
    message.DspBoardTemp = object.DspBoardTemp ?? 0;
    message.HeatSinkTemp = object.HeatSinkTemp ?? 0;
    message.MotorCurrentImaginary = object.MotorCurrentImaginary ?? 0;
    message.MotorCurrentReal = object.MotorCurrentReal ?? 0;
    message.MotorTemp = object.MotorTemp ?? 0;
    message.MotorVoltageImaginary = object.MotorVoltageImaginary ?? 0;
    message.MotorVoltageReal = object.MotorVoltageReal ?? 0;
    message.Odometer = object.Odometer ?? 0;
    message.PhaseBCurrent = object.PhaseBCurrent ?? 0;
    message.PhaseCCurrent = object.PhaseCCurrent ?? 0;
    message.SlipSpeed = object.SlipSpeed ?? 0;
    message.VoltageRail15VSupply = object.VoltageRail15VSupply ?? 0;
    message.VoltageRail1VSupply = object.VoltageRail1VSupply ?? 0;
    message.VoltageRail3VSupply = object.VoltageRail3VSupply ?? 0;
    return message;
  },
};

function createBaseIDriverControls(): IDriverControls {
  return {
    Acceleration: 0,
    Alive: false,
    Aux: false,
    Brakes: false,
    Forward: false,
    Hazard: false,
    HeadlightsHigh: false,
    HeadlightsLow: false,
    HeadlightsOff: false,
    Horn: false,
    Interior: false,
    Lap: false,
    NextSong: false,
    PrevSong: false,
    PushToTalk: false,
    RegenBraking: 0,
    Reset: false,
    Reverse: false,
    SignalLeft: false,
    SignalRight: false,
    VolumeDown: false,
    VolumeUp: false,
  };
}

export const IDriverControls: MessageFns<IDriverControls> = {
  encode(message: IDriverControls, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Acceleration !== 0) {
      writer.uint32(9).double(message.Acceleration);
    }
    if (message.Alive !== false) {
      writer.uint32(16).bool(message.Alive);
    }
    if (message.Aux !== false) {
      writer.uint32(24).bool(message.Aux);
    }
    if (message.Brakes !== false) {
      writer.uint32(32).bool(message.Brakes);
    }
    if (message.Forward !== false) {
      writer.uint32(40).bool(message.Forward);
    }
    if (message.Hazard !== false) {
      writer.uint32(48).bool(message.Hazard);
    }
    if (message.HeadlightsHigh !== false) {
      writer.uint32(56).bool(message.HeadlightsHigh);
    }
    if (message.HeadlightsLow !== false) {
      writer.uint32(64).bool(message.HeadlightsLow);
    }
    if (message.HeadlightsOff !== false) {
      writer.uint32(72).bool(message.HeadlightsOff);
    }
    if (message.Horn !== false) {
      writer.uint32(80).bool(message.Horn);
    }
    if (message.Interior !== false) {
      writer.uint32(88).bool(message.Interior);
    }
    if (message.Lap !== false) {
      writer.uint32(96).bool(message.Lap);
    }
    if (message.NextSong !== false) {
      writer.uint32(104).bool(message.NextSong);
    }
    if (message.PrevSong !== false) {
      writer.uint32(112).bool(message.PrevSong);
    }
    if (message.PushToTalk !== false) {
      writer.uint32(120).bool(message.PushToTalk);
    }
    if (message.RegenBraking !== 0) {
      writer.uint32(129).double(message.RegenBraking);
    }
    if (message.Reset !== false) {
      writer.uint32(136).bool(message.Reset);
    }
    if (message.Reverse !== false) {
      writer.uint32(144).bool(message.Reverse);
    }
    if (message.SignalLeft !== false) {
      writer.uint32(152).bool(message.SignalLeft);
    }
    if (message.SignalRight !== false) {
      writer.uint32(160).bool(message.SignalRight);
    }
    if (message.VolumeDown !== false) {
      writer.uint32(168).bool(message.VolumeDown);
    }
    if (message.VolumeUp !== false) {
      writer.uint32(176).bool(message.VolumeUp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IDriverControls {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIDriverControls();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.Acceleration = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.Alive = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.Aux = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.Brakes = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.Forward = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.Hazard = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.HeadlightsHigh = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.HeadlightsLow = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.HeadlightsOff = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.Horn = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.Interior = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.Lap = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.NextSong = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.PrevSong = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.PushToTalk = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 129) {
            break;
          }

          message.RegenBraking = reader.double();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.Reset = reader.bool();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.Reverse = reader.bool();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.SignalLeft = reader.bool();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.SignalRight = reader.bool();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.VolumeDown = reader.bool();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.VolumeUp = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IDriverControls {
    return {
      Acceleration: isSet(object.Acceleration) ? globalThis.Number(object.Acceleration) : 0,
      Alive: isSet(object.Alive) ? globalThis.Boolean(object.Alive) : false,
      Aux: isSet(object.Aux) ? globalThis.Boolean(object.Aux) : false,
      Brakes: isSet(object.Brakes) ? globalThis.Boolean(object.Brakes) : false,
      Forward: isSet(object.Forward) ? globalThis.Boolean(object.Forward) : false,
      Hazard: isSet(object.Hazard) ? globalThis.Boolean(object.Hazard) : false,
      HeadlightsHigh: isSet(object.HeadlightsHigh) ? globalThis.Boolean(object.HeadlightsHigh) : false,
      HeadlightsLow: isSet(object.HeadlightsLow) ? globalThis.Boolean(object.HeadlightsLow) : false,
      HeadlightsOff: isSet(object.HeadlightsOff) ? globalThis.Boolean(object.HeadlightsOff) : false,
      Horn: isSet(object.Horn) ? globalThis.Boolean(object.Horn) : false,
      Interior: isSet(object.Interior) ? globalThis.Boolean(object.Interior) : false,
      Lap: isSet(object.Lap) ? globalThis.Boolean(object.Lap) : false,
      NextSong: isSet(object.NextSong) ? globalThis.Boolean(object.NextSong) : false,
      PrevSong: isSet(object.PrevSong) ? globalThis.Boolean(object.PrevSong) : false,
      PushToTalk: isSet(object.PushToTalk) ? globalThis.Boolean(object.PushToTalk) : false,
      RegenBraking: isSet(object.RegenBraking) ? globalThis.Number(object.RegenBraking) : 0,
      Reset: isSet(object.Reset) ? globalThis.Boolean(object.Reset) : false,
      Reverse: isSet(object.Reverse) ? globalThis.Boolean(object.Reverse) : false,
      SignalLeft: isSet(object.SignalLeft) ? globalThis.Boolean(object.SignalLeft) : false,
      SignalRight: isSet(object.SignalRight) ? globalThis.Boolean(object.SignalRight) : false,
      VolumeDown: isSet(object.VolumeDown) ? globalThis.Boolean(object.VolumeDown) : false,
      VolumeUp: isSet(object.VolumeUp) ? globalThis.Boolean(object.VolumeUp) : false,
    };
  },

  toJSON(message: IDriverControls): unknown {
    const obj: any = {};
    if (message.Acceleration !== 0) {
      obj.Acceleration = message.Acceleration;
    }
    if (message.Alive !== false) {
      obj.Alive = message.Alive;
    }
    if (message.Aux !== false) {
      obj.Aux = message.Aux;
    }
    if (message.Brakes !== false) {
      obj.Brakes = message.Brakes;
    }
    if (message.Forward !== false) {
      obj.Forward = message.Forward;
    }
    if (message.Hazard !== false) {
      obj.Hazard = message.Hazard;
    }
    if (message.HeadlightsHigh !== false) {
      obj.HeadlightsHigh = message.HeadlightsHigh;
    }
    if (message.HeadlightsLow !== false) {
      obj.HeadlightsLow = message.HeadlightsLow;
    }
    if (message.HeadlightsOff !== false) {
      obj.HeadlightsOff = message.HeadlightsOff;
    }
    if (message.Horn !== false) {
      obj.Horn = message.Horn;
    }
    if (message.Interior !== false) {
      obj.Interior = message.Interior;
    }
    if (message.Lap !== false) {
      obj.Lap = message.Lap;
    }
    if (message.NextSong !== false) {
      obj.NextSong = message.NextSong;
    }
    if (message.PrevSong !== false) {
      obj.PrevSong = message.PrevSong;
    }
    if (message.PushToTalk !== false) {
      obj.PushToTalk = message.PushToTalk;
    }
    if (message.RegenBraking !== 0) {
      obj.RegenBraking = message.RegenBraking;
    }
    if (message.Reset !== false) {
      obj.Reset = message.Reset;
    }
    if (message.Reverse !== false) {
      obj.Reverse = message.Reverse;
    }
    if (message.SignalLeft !== false) {
      obj.SignalLeft = message.SignalLeft;
    }
    if (message.SignalRight !== false) {
      obj.SignalRight = message.SignalRight;
    }
    if (message.VolumeDown !== false) {
      obj.VolumeDown = message.VolumeDown;
    }
    if (message.VolumeUp !== false) {
      obj.VolumeUp = message.VolumeUp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IDriverControls>, I>>(base?: I): IDriverControls {
    return IDriverControls.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IDriverControls>, I>>(object: I): IDriverControls {
    const message = createBaseIDriverControls();
    message.Acceleration = object.Acceleration ?? 0;
    message.Alive = object.Alive ?? false;
    message.Aux = object.Aux ?? false;
    message.Brakes = object.Brakes ?? false;
    message.Forward = object.Forward ?? false;
    message.Hazard = object.Hazard ?? false;
    message.HeadlightsHigh = object.HeadlightsHigh ?? false;
    message.HeadlightsLow = object.HeadlightsLow ?? false;
    message.HeadlightsOff = object.HeadlightsOff ?? false;
    message.Horn = object.Horn ?? false;
    message.Interior = object.Interior ?? false;
    message.Lap = object.Lap ?? false;
    message.NextSong = object.NextSong ?? false;
    message.PrevSong = object.PrevSong ?? false;
    message.PushToTalk = object.PushToTalk ?? false;
    message.RegenBraking = object.RegenBraking ?? 0;
    message.Reset = object.Reset ?? false;
    message.Reverse = object.Reverse ?? false;
    message.SignalLeft = object.SignalLeft ?? false;
    message.SignalRight = object.SignalRight ?? false;
    message.VolumeDown = object.VolumeDown ?? false;
    message.VolumeUp = object.VolumeUp ?? false;
    return message;
  },
};

function createBaseILights(): ILights {
  return {
    Alive: false,
    BmsStrobeLight: false,
    Brakes: false,
    HighBeams: false,
    LeftSignal: false,
    LowBeams: false,
    RightSignal: false,
  };
}

export const ILights: MessageFns<ILights> = {
  encode(message: ILights, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Alive !== false) {
      writer.uint32(8).bool(message.Alive);
    }
    if (message.BmsStrobeLight !== false) {
      writer.uint32(16).bool(message.BmsStrobeLight);
    }
    if (message.Brakes !== false) {
      writer.uint32(24).bool(message.Brakes);
    }
    if (message.HighBeams !== false) {
      writer.uint32(32).bool(message.HighBeams);
    }
    if (message.LeftSignal !== false) {
      writer.uint32(40).bool(message.LeftSignal);
    }
    if (message.LowBeams !== false) {
      writer.uint32(48).bool(message.LowBeams);
    }
    if (message.RightSignal !== false) {
      writer.uint32(56).bool(message.RightSignal);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ILights {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseILights();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.Alive = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.BmsStrobeLight = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.Brakes = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.HighBeams = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.LeftSignal = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.LowBeams = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.RightSignal = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ILights {
    return {
      Alive: isSet(object.Alive) ? globalThis.Boolean(object.Alive) : false,
      BmsStrobeLight: isSet(object.BmsStrobeLight) ? globalThis.Boolean(object.BmsStrobeLight) : false,
      Brakes: isSet(object.Brakes) ? globalThis.Boolean(object.Brakes) : false,
      HighBeams: isSet(object.HighBeams) ? globalThis.Boolean(object.HighBeams) : false,
      LeftSignal: isSet(object.LeftSignal) ? globalThis.Boolean(object.LeftSignal) : false,
      LowBeams: isSet(object.LowBeams) ? globalThis.Boolean(object.LowBeams) : false,
      RightSignal: isSet(object.RightSignal) ? globalThis.Boolean(object.RightSignal) : false,
    };
  },

  toJSON(message: ILights): unknown {
    const obj: any = {};
    if (message.Alive !== false) {
      obj.Alive = message.Alive;
    }
    if (message.BmsStrobeLight !== false) {
      obj.BmsStrobeLight = message.BmsStrobeLight;
    }
    if (message.Brakes !== false) {
      obj.Brakes = message.Brakes;
    }
    if (message.HighBeams !== false) {
      obj.HighBeams = message.HighBeams;
    }
    if (message.LeftSignal !== false) {
      obj.LeftSignal = message.LeftSignal;
    }
    if (message.LowBeams !== false) {
      obj.LowBeams = message.LowBeams;
    }
    if (message.RightSignal !== false) {
      obj.RightSignal = message.RightSignal;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ILights>, I>>(base?: I): ILights {
    return ILights.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ILights>, I>>(object: I): ILights {
    const message = createBaseILights();
    message.Alive = object.Alive ?? false;
    message.BmsStrobeLight = object.BmsStrobeLight ?? false;
    message.Brakes = object.Brakes ?? false;
    message.HighBeams = object.HighBeams ?? false;
    message.LeftSignal = object.LeftSignal ?? false;
    message.LowBeams = object.LowBeams ?? false;
    message.RightSignal = object.RightSignal ?? false;
    return message;
  },
};

function createBaseIBatteryFault(): IBatteryFault {
  return { ErrorFlags: undefined, LimitFlags: undefined };
}

export const IBatteryFault: MessageFns<IBatteryFault> = {
  encode(message: IBatteryFault, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ErrorFlags !== undefined) {
      IBatteryErrorFlags.encode(message.ErrorFlags, writer.uint32(10).fork()).join();
    }
    if (message.LimitFlags !== undefined) {
      IBatteryLimitFlags.encode(message.LimitFlags, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IBatteryFault {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIBatteryFault();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ErrorFlags = IBatteryErrorFlags.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.LimitFlags = IBatteryLimitFlags.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IBatteryFault {
    return {
      ErrorFlags: isSet(object.ErrorFlags) ? IBatteryErrorFlags.fromJSON(object.ErrorFlags) : undefined,
      LimitFlags: isSet(object.LimitFlags) ? IBatteryLimitFlags.fromJSON(object.LimitFlags) : undefined,
    };
  },

  toJSON(message: IBatteryFault): unknown {
    const obj: any = {};
    if (message.ErrorFlags !== undefined) {
      obj.ErrorFlags = IBatteryErrorFlags.toJSON(message.ErrorFlags);
    }
    if (message.LimitFlags !== undefined) {
      obj.LimitFlags = IBatteryLimitFlags.toJSON(message.LimitFlags);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IBatteryFault>, I>>(base?: I): IBatteryFault {
    return IBatteryFault.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IBatteryFault>, I>>(object: I): IBatteryFault {
    const message = createBaseIBatteryFault();
    message.ErrorFlags = (object.ErrorFlags !== undefined && object.ErrorFlags !== null)
      ? IBatteryErrorFlags.fromPartial(object.ErrorFlags)
      : undefined;
    message.LimitFlags = (object.LimitFlags !== undefined && object.LimitFlags !== null)
      ? IBatteryLimitFlags.fromPartial(object.LimitFlags)
      : undefined;
    return message;
  },
};

function createBaseIBatteryErrorFlags(): IBatteryErrorFlags {
  return {
    PowerSupplyFault: false,
    AlwaysOnSupplyFault: false,
    CANBUSCommunicationsFault: false,
    ChargeLimitEnforcementFault: false,
    ChargerSafetyRelayFault: false,
    CurrentSensorFault: false,
    DischargeLimitEnforcementFault: false,
    FanMonitorFault: false,
    HighVoltageIsolationFault: false,
    InternalCommunicationFault: false,
    InternalConversionFault: false,
    InternalLogicFault: false,
    InternalMemoryFault: false,
    InternalThermistorsFault: false,
    LowCellVoltageFault: false,
    OpenWiringFault: false,
    PackVoltageSensorFault: false,
    ThermistorFault: false,
    VoltageRedundancyFault: false,
    WeakCellFault: false,
    WeakPackFault: false,
  };
}

export const IBatteryErrorFlags: MessageFns<IBatteryErrorFlags> = {
  encode(message: IBatteryErrorFlags, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.PowerSupplyFault !== false) {
      writer.uint32(8).bool(message.PowerSupplyFault);
    }
    if (message.AlwaysOnSupplyFault !== false) {
      writer.uint32(16).bool(message.AlwaysOnSupplyFault);
    }
    if (message.CANBUSCommunicationsFault !== false) {
      writer.uint32(24).bool(message.CANBUSCommunicationsFault);
    }
    if (message.ChargeLimitEnforcementFault !== false) {
      writer.uint32(32).bool(message.ChargeLimitEnforcementFault);
    }
    if (message.ChargerSafetyRelayFault !== false) {
      writer.uint32(40).bool(message.ChargerSafetyRelayFault);
    }
    if (message.CurrentSensorFault !== false) {
      writer.uint32(48).bool(message.CurrentSensorFault);
    }
    if (message.DischargeLimitEnforcementFault !== false) {
      writer.uint32(56).bool(message.DischargeLimitEnforcementFault);
    }
    if (message.FanMonitorFault !== false) {
      writer.uint32(64).bool(message.FanMonitorFault);
    }
    if (message.HighVoltageIsolationFault !== false) {
      writer.uint32(72).bool(message.HighVoltageIsolationFault);
    }
    if (message.InternalCommunicationFault !== false) {
      writer.uint32(80).bool(message.InternalCommunicationFault);
    }
    if (message.InternalConversionFault !== false) {
      writer.uint32(88).bool(message.InternalConversionFault);
    }
    if (message.InternalLogicFault !== false) {
      writer.uint32(96).bool(message.InternalLogicFault);
    }
    if (message.InternalMemoryFault !== false) {
      writer.uint32(104).bool(message.InternalMemoryFault);
    }
    if (message.InternalThermistorsFault !== false) {
      writer.uint32(112).bool(message.InternalThermistorsFault);
    }
    if (message.LowCellVoltageFault !== false) {
      writer.uint32(120).bool(message.LowCellVoltageFault);
    }
    if (message.OpenWiringFault !== false) {
      writer.uint32(128).bool(message.OpenWiringFault);
    }
    if (message.PackVoltageSensorFault !== false) {
      writer.uint32(136).bool(message.PackVoltageSensorFault);
    }
    if (message.ThermistorFault !== false) {
      writer.uint32(144).bool(message.ThermistorFault);
    }
    if (message.VoltageRedundancyFault !== false) {
      writer.uint32(152).bool(message.VoltageRedundancyFault);
    }
    if (message.WeakCellFault !== false) {
      writer.uint32(160).bool(message.WeakCellFault);
    }
    if (message.WeakPackFault !== false) {
      writer.uint32(168).bool(message.WeakPackFault);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IBatteryErrorFlags {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIBatteryErrorFlags();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.PowerSupplyFault = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.AlwaysOnSupplyFault = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.CANBUSCommunicationsFault = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ChargeLimitEnforcementFault = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.ChargerSafetyRelayFault = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.CurrentSensorFault = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.DischargeLimitEnforcementFault = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.FanMonitorFault = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.HighVoltageIsolationFault = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.InternalCommunicationFault = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.InternalConversionFault = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.InternalLogicFault = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.InternalMemoryFault = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.InternalThermistorsFault = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.LowCellVoltageFault = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.OpenWiringFault = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.PackVoltageSensorFault = reader.bool();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.ThermistorFault = reader.bool();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.VoltageRedundancyFault = reader.bool();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.WeakCellFault = reader.bool();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.WeakPackFault = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IBatteryErrorFlags {
    return {
      PowerSupplyFault: isSet(object.PowerSupplyFault) ? globalThis.Boolean(object.PowerSupplyFault) : false,
      AlwaysOnSupplyFault: isSet(object.AlwaysOnSupplyFault) ? globalThis.Boolean(object.AlwaysOnSupplyFault) : false,
      CANBUSCommunicationsFault: isSet(object.CANBUSCommunicationsFault)
        ? globalThis.Boolean(object.CANBUSCommunicationsFault)
        : false,
      ChargeLimitEnforcementFault: isSet(object.ChargeLimitEnforcementFault)
        ? globalThis.Boolean(object.ChargeLimitEnforcementFault)
        : false,
      ChargerSafetyRelayFault: isSet(object.ChargerSafetyRelayFault)
        ? globalThis.Boolean(object.ChargerSafetyRelayFault)
        : false,
      CurrentSensorFault: isSet(object.CurrentSensorFault) ? globalThis.Boolean(object.CurrentSensorFault) : false,
      DischargeLimitEnforcementFault: isSet(object.DischargeLimitEnforcementFault)
        ? globalThis.Boolean(object.DischargeLimitEnforcementFault)
        : false,
      FanMonitorFault: isSet(object.FanMonitorFault) ? globalThis.Boolean(object.FanMonitorFault) : false,
      HighVoltageIsolationFault: isSet(object.HighVoltageIsolationFault)
        ? globalThis.Boolean(object.HighVoltageIsolationFault)
        : false,
      InternalCommunicationFault: isSet(object.InternalCommunicationFault)
        ? globalThis.Boolean(object.InternalCommunicationFault)
        : false,
      InternalConversionFault: isSet(object.InternalConversionFault)
        ? globalThis.Boolean(object.InternalConversionFault)
        : false,
      InternalLogicFault: isSet(object.InternalLogicFault) ? globalThis.Boolean(object.InternalLogicFault) : false,
      InternalMemoryFault: isSet(object.InternalMemoryFault) ? globalThis.Boolean(object.InternalMemoryFault) : false,
      InternalThermistorsFault: isSet(object.InternalThermistorsFault)
        ? globalThis.Boolean(object.InternalThermistorsFault)
        : false,
      LowCellVoltageFault: isSet(object.LowCellVoltageFault) ? globalThis.Boolean(object.LowCellVoltageFault) : false,
      OpenWiringFault: isSet(object.OpenWiringFault) ? globalThis.Boolean(object.OpenWiringFault) : false,
      PackVoltageSensorFault: isSet(object.PackVoltageSensorFault)
        ? globalThis.Boolean(object.PackVoltageSensorFault)
        : false,
      ThermistorFault: isSet(object.ThermistorFault) ? globalThis.Boolean(object.ThermistorFault) : false,
      VoltageRedundancyFault: isSet(object.VoltageRedundancyFault)
        ? globalThis.Boolean(object.VoltageRedundancyFault)
        : false,
      WeakCellFault: isSet(object.WeakCellFault) ? globalThis.Boolean(object.WeakCellFault) : false,
      WeakPackFault: isSet(object.WeakPackFault) ? globalThis.Boolean(object.WeakPackFault) : false,
    };
  },

  toJSON(message: IBatteryErrorFlags): unknown {
    const obj: any = {};
    if (message.PowerSupplyFault !== false) {
      obj.PowerSupplyFault = message.PowerSupplyFault;
    }
    if (message.AlwaysOnSupplyFault !== false) {
      obj.AlwaysOnSupplyFault = message.AlwaysOnSupplyFault;
    }
    if (message.CANBUSCommunicationsFault !== false) {
      obj.CANBUSCommunicationsFault = message.CANBUSCommunicationsFault;
    }
    if (message.ChargeLimitEnforcementFault !== false) {
      obj.ChargeLimitEnforcementFault = message.ChargeLimitEnforcementFault;
    }
    if (message.ChargerSafetyRelayFault !== false) {
      obj.ChargerSafetyRelayFault = message.ChargerSafetyRelayFault;
    }
    if (message.CurrentSensorFault !== false) {
      obj.CurrentSensorFault = message.CurrentSensorFault;
    }
    if (message.DischargeLimitEnforcementFault !== false) {
      obj.DischargeLimitEnforcementFault = message.DischargeLimitEnforcementFault;
    }
    if (message.FanMonitorFault !== false) {
      obj.FanMonitorFault = message.FanMonitorFault;
    }
    if (message.HighVoltageIsolationFault !== false) {
      obj.HighVoltageIsolationFault = message.HighVoltageIsolationFault;
    }
    if (message.InternalCommunicationFault !== false) {
      obj.InternalCommunicationFault = message.InternalCommunicationFault;
    }
    if (message.InternalConversionFault !== false) {
      obj.InternalConversionFault = message.InternalConversionFault;
    }
    if (message.InternalLogicFault !== false) {
      obj.InternalLogicFault = message.InternalLogicFault;
    }
    if (message.InternalMemoryFault !== false) {
      obj.InternalMemoryFault = message.InternalMemoryFault;
    }
    if (message.InternalThermistorsFault !== false) {
      obj.InternalThermistorsFault = message.InternalThermistorsFault;
    }
    if (message.LowCellVoltageFault !== false) {
      obj.LowCellVoltageFault = message.LowCellVoltageFault;
    }
    if (message.OpenWiringFault !== false) {
      obj.OpenWiringFault = message.OpenWiringFault;
    }
    if (message.PackVoltageSensorFault !== false) {
      obj.PackVoltageSensorFault = message.PackVoltageSensorFault;
    }
    if (message.ThermistorFault !== false) {
      obj.ThermistorFault = message.ThermistorFault;
    }
    if (message.VoltageRedundancyFault !== false) {
      obj.VoltageRedundancyFault = message.VoltageRedundancyFault;
    }
    if (message.WeakCellFault !== false) {
      obj.WeakCellFault = message.WeakCellFault;
    }
    if (message.WeakPackFault !== false) {
      obj.WeakPackFault = message.WeakPackFault;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IBatteryErrorFlags>, I>>(base?: I): IBatteryErrorFlags {
    return IBatteryErrorFlags.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IBatteryErrorFlags>, I>>(object: I): IBatteryErrorFlags {
    const message = createBaseIBatteryErrorFlags();
    message.PowerSupplyFault = object.PowerSupplyFault ?? false;
    message.AlwaysOnSupplyFault = object.AlwaysOnSupplyFault ?? false;
    message.CANBUSCommunicationsFault = object.CANBUSCommunicationsFault ?? false;
    message.ChargeLimitEnforcementFault = object.ChargeLimitEnforcementFault ?? false;
    message.ChargerSafetyRelayFault = object.ChargerSafetyRelayFault ?? false;
    message.CurrentSensorFault = object.CurrentSensorFault ?? false;
    message.DischargeLimitEnforcementFault = object.DischargeLimitEnforcementFault ?? false;
    message.FanMonitorFault = object.FanMonitorFault ?? false;
    message.HighVoltageIsolationFault = object.HighVoltageIsolationFault ?? false;
    message.InternalCommunicationFault = object.InternalCommunicationFault ?? false;
    message.InternalConversionFault = object.InternalConversionFault ?? false;
    message.InternalLogicFault = object.InternalLogicFault ?? false;
    message.InternalMemoryFault = object.InternalMemoryFault ?? false;
    message.InternalThermistorsFault = object.InternalThermistorsFault ?? false;
    message.LowCellVoltageFault = object.LowCellVoltageFault ?? false;
    message.OpenWiringFault = object.OpenWiringFault ?? false;
    message.PackVoltageSensorFault = object.PackVoltageSensorFault ?? false;
    message.ThermistorFault = object.ThermistorFault ?? false;
    message.VoltageRedundancyFault = object.VoltageRedundancyFault ?? false;
    message.WeakCellFault = object.WeakCellFault ?? false;
    message.WeakPackFault = object.WeakPackFault ?? false;
    return message;
  },
};

function createBaseIBatteryLimitFlags(): IBatteryLimitFlags {
  return {
    CclReducedDueToAlternateCurrentLimit: false,
    CclReducedDueToChargerLatch: false,
    CclReducedDueToHighCellResistance: false,
    CclReducedDueToHighCellVoltage: false,
    CclReducedDueToHighPackVoltage: false,
    CclReducedDueToHighSoc: false,
    CclReducedDueToTemperature: false,
    DclReducedDueToHighCellResistance: false,
    DclReducedDueToLowCellVoltage: false,
    DclReducedDueToLowPackVoltage: false,
    DclReducedDueToLowSoc: false,
    DclReducedDueToTemperature: false,
    DclandCclReducedDueToCommunicationFailsafe: false,
    DclandCclReducedDueToVoltageFailsafe: false,
  };
}

export const IBatteryLimitFlags: MessageFns<IBatteryLimitFlags> = {
  encode(message: IBatteryLimitFlags, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.CclReducedDueToAlternateCurrentLimit !== false) {
      writer.uint32(8).bool(message.CclReducedDueToAlternateCurrentLimit);
    }
    if (message.CclReducedDueToChargerLatch !== false) {
      writer.uint32(16).bool(message.CclReducedDueToChargerLatch);
    }
    if (message.CclReducedDueToHighCellResistance !== false) {
      writer.uint32(24).bool(message.CclReducedDueToHighCellResistance);
    }
    if (message.CclReducedDueToHighCellVoltage !== false) {
      writer.uint32(32).bool(message.CclReducedDueToHighCellVoltage);
    }
    if (message.CclReducedDueToHighPackVoltage !== false) {
      writer.uint32(40).bool(message.CclReducedDueToHighPackVoltage);
    }
    if (message.CclReducedDueToHighSoc !== false) {
      writer.uint32(48).bool(message.CclReducedDueToHighSoc);
    }
    if (message.CclReducedDueToTemperature !== false) {
      writer.uint32(56).bool(message.CclReducedDueToTemperature);
    }
    if (message.DclReducedDueToHighCellResistance !== false) {
      writer.uint32(64).bool(message.DclReducedDueToHighCellResistance);
    }
    if (message.DclReducedDueToLowCellVoltage !== false) {
      writer.uint32(72).bool(message.DclReducedDueToLowCellVoltage);
    }
    if (message.DclReducedDueToLowPackVoltage !== false) {
      writer.uint32(80).bool(message.DclReducedDueToLowPackVoltage);
    }
    if (message.DclReducedDueToLowSoc !== false) {
      writer.uint32(88).bool(message.DclReducedDueToLowSoc);
    }
    if (message.DclReducedDueToTemperature !== false) {
      writer.uint32(96).bool(message.DclReducedDueToTemperature);
    }
    if (message.DclandCclReducedDueToCommunicationFailsafe !== false) {
      writer.uint32(104).bool(message.DclandCclReducedDueToCommunicationFailsafe);
    }
    if (message.DclandCclReducedDueToVoltageFailsafe !== false) {
      writer.uint32(112).bool(message.DclandCclReducedDueToVoltageFailsafe);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IBatteryLimitFlags {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIBatteryLimitFlags();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.CclReducedDueToAlternateCurrentLimit = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.CclReducedDueToChargerLatch = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.CclReducedDueToHighCellResistance = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.CclReducedDueToHighCellVoltage = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.CclReducedDueToHighPackVoltage = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.CclReducedDueToHighSoc = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.CclReducedDueToTemperature = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.DclReducedDueToHighCellResistance = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.DclReducedDueToLowCellVoltage = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.DclReducedDueToLowPackVoltage = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.DclReducedDueToLowSoc = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.DclReducedDueToTemperature = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.DclandCclReducedDueToCommunicationFailsafe = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.DclandCclReducedDueToVoltageFailsafe = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IBatteryLimitFlags {
    return {
      CclReducedDueToAlternateCurrentLimit: isSet(object.CclReducedDueToAlternateCurrentLimit)
        ? globalThis.Boolean(object.CclReducedDueToAlternateCurrentLimit)
        : false,
      CclReducedDueToChargerLatch: isSet(object.CclReducedDueToChargerLatch)
        ? globalThis.Boolean(object.CclReducedDueToChargerLatch)
        : false,
      CclReducedDueToHighCellResistance: isSet(object.CclReducedDueToHighCellResistance)
        ? globalThis.Boolean(object.CclReducedDueToHighCellResistance)
        : false,
      CclReducedDueToHighCellVoltage: isSet(object.CclReducedDueToHighCellVoltage)
        ? globalThis.Boolean(object.CclReducedDueToHighCellVoltage)
        : false,
      CclReducedDueToHighPackVoltage: isSet(object.CclReducedDueToHighPackVoltage)
        ? globalThis.Boolean(object.CclReducedDueToHighPackVoltage)
        : false,
      CclReducedDueToHighSoc: isSet(object.CclReducedDueToHighSoc)
        ? globalThis.Boolean(object.CclReducedDueToHighSoc)
        : false,
      CclReducedDueToTemperature: isSet(object.CclReducedDueToTemperature)
        ? globalThis.Boolean(object.CclReducedDueToTemperature)
        : false,
      DclReducedDueToHighCellResistance: isSet(object.DclReducedDueToHighCellResistance)
        ? globalThis.Boolean(object.DclReducedDueToHighCellResistance)
        : false,
      DclReducedDueToLowCellVoltage: isSet(object.DclReducedDueToLowCellVoltage)
        ? globalThis.Boolean(object.DclReducedDueToLowCellVoltage)
        : false,
      DclReducedDueToLowPackVoltage: isSet(object.DclReducedDueToLowPackVoltage)
        ? globalThis.Boolean(object.DclReducedDueToLowPackVoltage)
        : false,
      DclReducedDueToLowSoc: isSet(object.DclReducedDueToLowSoc)
        ? globalThis.Boolean(object.DclReducedDueToLowSoc)
        : false,
      DclReducedDueToTemperature: isSet(object.DclReducedDueToTemperature)
        ? globalThis.Boolean(object.DclReducedDueToTemperature)
        : false,
      DclandCclReducedDueToCommunicationFailsafe: isSet(object.DclandCclReducedDueToCommunicationFailsafe)
        ? globalThis.Boolean(object.DclandCclReducedDueToCommunicationFailsafe)
        : false,
      DclandCclReducedDueToVoltageFailsafe: isSet(object.DclandCclReducedDueToVoltageFailsafe)
        ? globalThis.Boolean(object.DclandCclReducedDueToVoltageFailsafe)
        : false,
    };
  },

  toJSON(message: IBatteryLimitFlags): unknown {
    const obj: any = {};
    if (message.CclReducedDueToAlternateCurrentLimit !== false) {
      obj.CclReducedDueToAlternateCurrentLimit = message.CclReducedDueToAlternateCurrentLimit;
    }
    if (message.CclReducedDueToChargerLatch !== false) {
      obj.CclReducedDueToChargerLatch = message.CclReducedDueToChargerLatch;
    }
    if (message.CclReducedDueToHighCellResistance !== false) {
      obj.CclReducedDueToHighCellResistance = message.CclReducedDueToHighCellResistance;
    }
    if (message.CclReducedDueToHighCellVoltage !== false) {
      obj.CclReducedDueToHighCellVoltage = message.CclReducedDueToHighCellVoltage;
    }
    if (message.CclReducedDueToHighPackVoltage !== false) {
      obj.CclReducedDueToHighPackVoltage = message.CclReducedDueToHighPackVoltage;
    }
    if (message.CclReducedDueToHighSoc !== false) {
      obj.CclReducedDueToHighSoc = message.CclReducedDueToHighSoc;
    }
    if (message.CclReducedDueToTemperature !== false) {
      obj.CclReducedDueToTemperature = message.CclReducedDueToTemperature;
    }
    if (message.DclReducedDueToHighCellResistance !== false) {
      obj.DclReducedDueToHighCellResistance = message.DclReducedDueToHighCellResistance;
    }
    if (message.DclReducedDueToLowCellVoltage !== false) {
      obj.DclReducedDueToLowCellVoltage = message.DclReducedDueToLowCellVoltage;
    }
    if (message.DclReducedDueToLowPackVoltage !== false) {
      obj.DclReducedDueToLowPackVoltage = message.DclReducedDueToLowPackVoltage;
    }
    if (message.DclReducedDueToLowSoc !== false) {
      obj.DclReducedDueToLowSoc = message.DclReducedDueToLowSoc;
    }
    if (message.DclReducedDueToTemperature !== false) {
      obj.DclReducedDueToTemperature = message.DclReducedDueToTemperature;
    }
    if (message.DclandCclReducedDueToCommunicationFailsafe !== false) {
      obj.DclandCclReducedDueToCommunicationFailsafe = message.DclandCclReducedDueToCommunicationFailsafe;
    }
    if (message.DclandCclReducedDueToVoltageFailsafe !== false) {
      obj.DclandCclReducedDueToVoltageFailsafe = message.DclandCclReducedDueToVoltageFailsafe;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IBatteryLimitFlags>, I>>(base?: I): IBatteryLimitFlags {
    return IBatteryLimitFlags.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IBatteryLimitFlags>, I>>(object: I): IBatteryLimitFlags {
    const message = createBaseIBatteryLimitFlags();
    message.CclReducedDueToAlternateCurrentLimit = object.CclReducedDueToAlternateCurrentLimit ?? false;
    message.CclReducedDueToChargerLatch = object.CclReducedDueToChargerLatch ?? false;
    message.CclReducedDueToHighCellResistance = object.CclReducedDueToHighCellResistance ?? false;
    message.CclReducedDueToHighCellVoltage = object.CclReducedDueToHighCellVoltage ?? false;
    message.CclReducedDueToHighPackVoltage = object.CclReducedDueToHighPackVoltage ?? false;
    message.CclReducedDueToHighSoc = object.CclReducedDueToHighSoc ?? false;
    message.CclReducedDueToTemperature = object.CclReducedDueToTemperature ?? false;
    message.DclReducedDueToHighCellResistance = object.DclReducedDueToHighCellResistance ?? false;
    message.DclReducedDueToLowCellVoltage = object.DclReducedDueToLowCellVoltage ?? false;
    message.DclReducedDueToLowPackVoltage = object.DclReducedDueToLowPackVoltage ?? false;
    message.DclReducedDueToLowSoc = object.DclReducedDueToLowSoc ?? false;
    message.DclReducedDueToTemperature = object.DclReducedDueToTemperature ?? false;
    message.DclandCclReducedDueToCommunicationFailsafe = object.DclandCclReducedDueToCommunicationFailsafe ?? false;
    message.DclandCclReducedDueToVoltageFailsafe = object.DclandCclReducedDueToVoltageFailsafe ?? false;
    return message;
  },
};

function createBaseICcs(): ICcs {
  return { CcsAlive: false };
}

export const ICcs: MessageFns<ICcs> = {
  encode(message: ICcs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.CcsAlive !== false) {
      writer.uint32(8).bool(message.CcsAlive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ICcs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseICcs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.CcsAlive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ICcs {
    return { CcsAlive: isSet(object.CcsAlive) ? globalThis.Boolean(object.CcsAlive) : false };
  },

  toJSON(message: ICcs): unknown {
    const obj: any = {};
    if (message.CcsAlive !== false) {
      obj.CcsAlive = message.CcsAlive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ICcs>, I>>(base?: I): ICcs {
    return ICcs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ICcs>, I>>(object: I): ICcs {
    const message = createBaseICcs();
    message.CcsAlive = object.CcsAlive ?? false;
    return message;
  },
};

function createBaseIMPPT(): IMPPT {
  return { Alive: false, ArrayCurrent: 0, ArrayVoltage: 0, BatteryVoltage: 0, Temperature: 0 };
}

export const IMPPT: MessageFns<IMPPT> = {
  encode(message: IMPPT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Alive !== false) {
      writer.uint32(8).bool(message.Alive);
    }
    if (message.ArrayCurrent !== 0) {
      writer.uint32(17).double(message.ArrayCurrent);
    }
    if (message.ArrayVoltage !== 0) {
      writer.uint32(25).double(message.ArrayVoltage);
    }
    if (message.BatteryVoltage !== 0) {
      writer.uint32(33).double(message.BatteryVoltage);
    }
    if (message.Temperature !== 0) {
      writer.uint32(41).double(message.Temperature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IMPPT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIMPPT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.Alive = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.ArrayCurrent = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.ArrayVoltage = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.BatteryVoltage = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.Temperature = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IMPPT {
    return {
      Alive: isSet(object.Alive) ? globalThis.Boolean(object.Alive) : false,
      ArrayCurrent: isSet(object.ArrayCurrent) ? globalThis.Number(object.ArrayCurrent) : 0,
      ArrayVoltage: isSet(object.ArrayVoltage) ? globalThis.Number(object.ArrayVoltage) : 0,
      BatteryVoltage: isSet(object.BatteryVoltage) ? globalThis.Number(object.BatteryVoltage) : 0,
      Temperature: isSet(object.Temperature) ? globalThis.Number(object.Temperature) : 0,
    };
  },

  toJSON(message: IMPPT): unknown {
    const obj: any = {};
    if (message.Alive !== false) {
      obj.Alive = message.Alive;
    }
    if (message.ArrayCurrent !== 0) {
      obj.ArrayCurrent = message.ArrayCurrent;
    }
    if (message.ArrayVoltage !== 0) {
      obj.ArrayVoltage = message.ArrayVoltage;
    }
    if (message.BatteryVoltage !== 0) {
      obj.BatteryVoltage = message.BatteryVoltage;
    }
    if (message.Temperature !== 0) {
      obj.Temperature = message.Temperature;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IMPPT>, I>>(base?: I): IMPPT {
    return IMPPT.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IMPPT>, I>>(object: I): IMPPT {
    const message = createBaseIMPPT();
    message.Alive = object.Alive ?? false;
    message.ArrayCurrent = object.ArrayCurrent ?? 0;
    message.ArrayVoltage = object.ArrayVoltage ?? 0;
    message.BatteryVoltage = object.BatteryVoltage ?? 0;
    message.Temperature = object.Temperature ?? 0;
    return message;
  },
};

function createBaseIMotorFault(): IMotorFault {
  return { ErrorFlags: undefined, LimitFlags: undefined, RxErrorCount: 0, TxErrorCount: 0 };
}

export const IMotorFault: MessageFns<IMotorFault> = {
  encode(message: IMotorFault, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ErrorFlags !== undefined) {
      IMotorErrorFlags.encode(message.ErrorFlags, writer.uint32(10).fork()).join();
    }
    if (message.LimitFlags !== undefined) {
      IMotorLimitFlags.encode(message.LimitFlags, writer.uint32(18).fork()).join();
    }
    if (message.RxErrorCount !== 0) {
      writer.uint32(24).int32(message.RxErrorCount);
    }
    if (message.TxErrorCount !== 0) {
      writer.uint32(32).int32(message.TxErrorCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IMotorFault {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIMotorFault();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ErrorFlags = IMotorErrorFlags.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.LimitFlags = IMotorLimitFlags.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.RxErrorCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.TxErrorCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IMotorFault {
    return {
      ErrorFlags: isSet(object.ErrorFlags) ? IMotorErrorFlags.fromJSON(object.ErrorFlags) : undefined,
      LimitFlags: isSet(object.LimitFlags) ? IMotorLimitFlags.fromJSON(object.LimitFlags) : undefined,
      RxErrorCount: isSet(object.RxErrorCount) ? globalThis.Number(object.RxErrorCount) : 0,
      TxErrorCount: isSet(object.TxErrorCount) ? globalThis.Number(object.TxErrorCount) : 0,
    };
  },

  toJSON(message: IMotorFault): unknown {
    const obj: any = {};
    if (message.ErrorFlags !== undefined) {
      obj.ErrorFlags = IMotorErrorFlags.toJSON(message.ErrorFlags);
    }
    if (message.LimitFlags !== undefined) {
      obj.LimitFlags = IMotorLimitFlags.toJSON(message.LimitFlags);
    }
    if (message.RxErrorCount !== 0) {
      obj.RxErrorCount = Math.round(message.RxErrorCount);
    }
    if (message.TxErrorCount !== 0) {
      obj.TxErrorCount = Math.round(message.TxErrorCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IMotorFault>, I>>(base?: I): IMotorFault {
    return IMotorFault.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IMotorFault>, I>>(object: I): IMotorFault {
    const message = createBaseIMotorFault();
    message.ErrorFlags = (object.ErrorFlags !== undefined && object.ErrorFlags !== null)
      ? IMotorErrorFlags.fromPartial(object.ErrorFlags)
      : undefined;
    message.LimitFlags = (object.LimitFlags !== undefined && object.LimitFlags !== null)
      ? IMotorLimitFlags.fromPartial(object.LimitFlags)
      : undefined;
    message.RxErrorCount = object.RxErrorCount ?? 0;
    message.TxErrorCount = object.TxErrorCount ?? 0;
    return message;
  },
};

function createBaseIMotorErrorFlags(): IMotorErrorFlags {
  return {
    BadMotorPositionHallSequence: false,
    ConfigReadError: false,
    DcBusOverVoltage: false,
    DesaturationFault: false,
    MotorOverSpeed: false,
    SoftwareOverCurrent: false,
    Wail15VUnderVoltageLockOut: false,
    WatchdogCausedLastReset: false,
  };
}

export const IMotorErrorFlags: MessageFns<IMotorErrorFlags> = {
  encode(message: IMotorErrorFlags, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.BadMotorPositionHallSequence !== false) {
      writer.uint32(8).bool(message.BadMotorPositionHallSequence);
    }
    if (message.ConfigReadError !== false) {
      writer.uint32(16).bool(message.ConfigReadError);
    }
    if (message.DcBusOverVoltage !== false) {
      writer.uint32(24).bool(message.DcBusOverVoltage);
    }
    if (message.DesaturationFault !== false) {
      writer.uint32(32).bool(message.DesaturationFault);
    }
    if (message.MotorOverSpeed !== false) {
      writer.uint32(40).bool(message.MotorOverSpeed);
    }
    if (message.SoftwareOverCurrent !== false) {
      writer.uint32(48).bool(message.SoftwareOverCurrent);
    }
    if (message.Wail15VUnderVoltageLockOut !== false) {
      writer.uint32(56).bool(message.Wail15VUnderVoltageLockOut);
    }
    if (message.WatchdogCausedLastReset !== false) {
      writer.uint32(64).bool(message.WatchdogCausedLastReset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IMotorErrorFlags {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIMotorErrorFlags();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.BadMotorPositionHallSequence = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.ConfigReadError = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.DcBusOverVoltage = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.DesaturationFault = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.MotorOverSpeed = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.SoftwareOverCurrent = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.Wail15VUnderVoltageLockOut = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.WatchdogCausedLastReset = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IMotorErrorFlags {
    return {
      BadMotorPositionHallSequence: isSet(object.BadMotorPositionHallSequence)
        ? globalThis.Boolean(object.BadMotorPositionHallSequence)
        : false,
      ConfigReadError: isSet(object.ConfigReadError) ? globalThis.Boolean(object.ConfigReadError) : false,
      DcBusOverVoltage: isSet(object.DcBusOverVoltage) ? globalThis.Boolean(object.DcBusOverVoltage) : false,
      DesaturationFault: isSet(object.DesaturationFault) ? globalThis.Boolean(object.DesaturationFault) : false,
      MotorOverSpeed: isSet(object.MotorOverSpeed) ? globalThis.Boolean(object.MotorOverSpeed) : false,
      SoftwareOverCurrent: isSet(object.SoftwareOverCurrent) ? globalThis.Boolean(object.SoftwareOverCurrent) : false,
      Wail15VUnderVoltageLockOut: isSet(object.Wail15VUnderVoltageLockOut)
        ? globalThis.Boolean(object.Wail15VUnderVoltageLockOut)
        : false,
      WatchdogCausedLastReset: isSet(object.WatchdogCausedLastReset)
        ? globalThis.Boolean(object.WatchdogCausedLastReset)
        : false,
    };
  },

  toJSON(message: IMotorErrorFlags): unknown {
    const obj: any = {};
    if (message.BadMotorPositionHallSequence !== false) {
      obj.BadMotorPositionHallSequence = message.BadMotorPositionHallSequence;
    }
    if (message.ConfigReadError !== false) {
      obj.ConfigReadError = message.ConfigReadError;
    }
    if (message.DcBusOverVoltage !== false) {
      obj.DcBusOverVoltage = message.DcBusOverVoltage;
    }
    if (message.DesaturationFault !== false) {
      obj.DesaturationFault = message.DesaturationFault;
    }
    if (message.MotorOverSpeed !== false) {
      obj.MotorOverSpeed = message.MotorOverSpeed;
    }
    if (message.SoftwareOverCurrent !== false) {
      obj.SoftwareOverCurrent = message.SoftwareOverCurrent;
    }
    if (message.Wail15VUnderVoltageLockOut !== false) {
      obj.Wail15VUnderVoltageLockOut = message.Wail15VUnderVoltageLockOut;
    }
    if (message.WatchdogCausedLastReset !== false) {
      obj.WatchdogCausedLastReset = message.WatchdogCausedLastReset;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IMotorErrorFlags>, I>>(base?: I): IMotorErrorFlags {
    return IMotorErrorFlags.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IMotorErrorFlags>, I>>(object: I): IMotorErrorFlags {
    const message = createBaseIMotorErrorFlags();
    message.BadMotorPositionHallSequence = object.BadMotorPositionHallSequence ?? false;
    message.ConfigReadError = object.ConfigReadError ?? false;
    message.DcBusOverVoltage = object.DcBusOverVoltage ?? false;
    message.DesaturationFault = object.DesaturationFault ?? false;
    message.MotorOverSpeed = object.MotorOverSpeed ?? false;
    message.SoftwareOverCurrent = object.SoftwareOverCurrent ?? false;
    message.Wail15VUnderVoltageLockOut = object.Wail15VUnderVoltageLockOut ?? false;
    message.WatchdogCausedLastReset = object.WatchdogCausedLastReset ?? false;
    return message;
  },
};

function createBaseIMotorLimitFlags(): IMotorLimitFlags {
  return {
    BusCurrent: false,
    BusVoltageLower: false,
    BusVoltageUpper: false,
    IpmOrMotorTemperature: false,
    MotorCurrent: false,
    OutputVoltagePwm: false,
    Velocity: false,
  };
}

export const IMotorLimitFlags: MessageFns<IMotorLimitFlags> = {
  encode(message: IMotorLimitFlags, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.BusCurrent !== false) {
      writer.uint32(8).bool(message.BusCurrent);
    }
    if (message.BusVoltageLower !== false) {
      writer.uint32(16).bool(message.BusVoltageLower);
    }
    if (message.BusVoltageUpper !== false) {
      writer.uint32(24).bool(message.BusVoltageUpper);
    }
    if (message.IpmOrMotorTemperature !== false) {
      writer.uint32(32).bool(message.IpmOrMotorTemperature);
    }
    if (message.MotorCurrent !== false) {
      writer.uint32(40).bool(message.MotorCurrent);
    }
    if (message.OutputVoltagePwm !== false) {
      writer.uint32(48).bool(message.OutputVoltagePwm);
    }
    if (message.Velocity !== false) {
      writer.uint32(56).bool(message.Velocity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IMotorLimitFlags {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIMotorLimitFlags();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.BusCurrent = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.BusVoltageLower = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.BusVoltageUpper = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.IpmOrMotorTemperature = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.MotorCurrent = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.OutputVoltagePwm = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.Velocity = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IMotorLimitFlags {
    return {
      BusCurrent: isSet(object.BusCurrent) ? globalThis.Boolean(object.BusCurrent) : false,
      BusVoltageLower: isSet(object.BusVoltageLower) ? globalThis.Boolean(object.BusVoltageLower) : false,
      BusVoltageUpper: isSet(object.BusVoltageUpper) ? globalThis.Boolean(object.BusVoltageUpper) : false,
      IpmOrMotorTemperature: isSet(object.IpmOrMotorTemperature)
        ? globalThis.Boolean(object.IpmOrMotorTemperature)
        : false,
      MotorCurrent: isSet(object.MotorCurrent) ? globalThis.Boolean(object.MotorCurrent) : false,
      OutputVoltagePwm: isSet(object.OutputVoltagePwm) ? globalThis.Boolean(object.OutputVoltagePwm) : false,
      Velocity: isSet(object.Velocity) ? globalThis.Boolean(object.Velocity) : false,
    };
  },

  toJSON(message: IMotorLimitFlags): unknown {
    const obj: any = {};
    if (message.BusCurrent !== false) {
      obj.BusCurrent = message.BusCurrent;
    }
    if (message.BusVoltageLower !== false) {
      obj.BusVoltageLower = message.BusVoltageLower;
    }
    if (message.BusVoltageUpper !== false) {
      obj.BusVoltageUpper = message.BusVoltageUpper;
    }
    if (message.IpmOrMotorTemperature !== false) {
      obj.IpmOrMotorTemperature = message.IpmOrMotorTemperature;
    }
    if (message.MotorCurrent !== false) {
      obj.MotorCurrent = message.MotorCurrent;
    }
    if (message.OutputVoltagePwm !== false) {
      obj.OutputVoltagePwm = message.OutputVoltagePwm;
    }
    if (message.Velocity !== false) {
      obj.Velocity = message.Velocity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IMotorLimitFlags>, I>>(base?: I): IMotorLimitFlags {
    return IMotorLimitFlags.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IMotorLimitFlags>, I>>(object: I): IMotorLimitFlags {
    const message = createBaseIMotorLimitFlags();
    message.BusCurrent = object.BusCurrent ?? false;
    message.BusVoltageLower = object.BusVoltageLower ?? false;
    message.BusVoltageUpper = object.BusVoltageUpper ?? false;
    message.IpmOrMotorTemperature = object.IpmOrMotorTemperature ?? false;
    message.MotorCurrent = object.MotorCurrent ?? false;
    message.OutputVoltagePwm = object.OutputVoltagePwm ?? false;
    message.Velocity = object.Velocity ?? false;
    return message;
  },
};

function createBaseIBattery(): IBattery {
  return {
    InputVoltage: 0,
    Alive: false,
    AverageCellVoltage: 0,
    AverageTemperature: 0,
    BMSRelayStatusFlags: undefined,
    FanSpeed: 0,
    FanVoltage: 0,
    HighCellVoltage: 0,
    HighCellVoltageId: 0,
    HighTemperature: 0,
    HighThermistorId: 0,
    InternalTemperature: 0,
    LowCellVoltage: 0,
    LowCellVoltageId: 0,
    LowTemperature: 0,
    LowThermistorId: 0,
    PackAmphours: 0,
    PackCurrent: 0,
    PackDepthOfDischarge: 0,
    PackStateOfCharge: 0,
    PackVoltage: 0,
    PopulatedCells: 0,
    RequestedFanSpeed: 0,
  };
}

export const IBattery: MessageFns<IBattery> = {
  encode(message: IBattery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.InputVoltage !== 0) {
      writer.uint32(9).double(message.InputVoltage);
    }
    if (message.Alive !== false) {
      writer.uint32(16).bool(message.Alive);
    }
    if (message.AverageCellVoltage !== 0) {
      writer.uint32(25).double(message.AverageCellVoltage);
    }
    if (message.AverageTemperature !== 0) {
      writer.uint32(33).double(message.AverageTemperature);
    }
    if (message.BMSRelayStatusFlags !== undefined) {
      IBMSRelayStatusFlags.encode(message.BMSRelayStatusFlags, writer.uint32(42).fork()).join();
    }
    if (message.FanSpeed !== 0) {
      writer.uint32(49).double(message.FanSpeed);
    }
    if (message.FanVoltage !== 0) {
      writer.uint32(57).double(message.FanVoltage);
    }
    if (message.HighCellVoltage !== 0) {
      writer.uint32(65).double(message.HighCellVoltage);
    }
    if (message.HighCellVoltageId !== 0) {
      writer.uint32(72).int32(message.HighCellVoltageId);
    }
    if (message.HighTemperature !== 0) {
      writer.uint32(81).double(message.HighTemperature);
    }
    if (message.HighThermistorId !== 0) {
      writer.uint32(88).int32(message.HighThermistorId);
    }
    if (message.InternalTemperature !== 0) {
      writer.uint32(97).double(message.InternalTemperature);
    }
    if (message.LowCellVoltage !== 0) {
      writer.uint32(105).double(message.LowCellVoltage);
    }
    if (message.LowCellVoltageId !== 0) {
      writer.uint32(112).int32(message.LowCellVoltageId);
    }
    if (message.LowTemperature !== 0) {
      writer.uint32(121).double(message.LowTemperature);
    }
    if (message.LowThermistorId !== 0) {
      writer.uint32(128).int32(message.LowThermistorId);
    }
    if (message.PackAmphours !== 0) {
      writer.uint32(137).double(message.PackAmphours);
    }
    if (message.PackCurrent !== 0) {
      writer.uint32(145).double(message.PackCurrent);
    }
    if (message.PackDepthOfDischarge !== 0) {
      writer.uint32(153).double(message.PackDepthOfDischarge);
    }
    if (message.PackStateOfCharge !== 0) {
      writer.uint32(161).double(message.PackStateOfCharge);
    }
    if (message.PackVoltage !== 0) {
      writer.uint32(169).double(message.PackVoltage);
    }
    if (message.PopulatedCells !== 0) {
      writer.uint32(176).int32(message.PopulatedCells);
    }
    if (message.RequestedFanSpeed !== 0) {
      writer.uint32(185).double(message.RequestedFanSpeed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IBattery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIBattery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.InputVoltage = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.Alive = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.AverageCellVoltage = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.AverageTemperature = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.BMSRelayStatusFlags = IBMSRelayStatusFlags.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.FanSpeed = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.FanVoltage = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 65) {
            break;
          }

          message.HighCellVoltage = reader.double();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.HighCellVoltageId = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 81) {
            break;
          }

          message.HighTemperature = reader.double();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.HighThermistorId = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 97) {
            break;
          }

          message.InternalTemperature = reader.double();
          continue;
        }
        case 13: {
          if (tag !== 105) {
            break;
          }

          message.LowCellVoltage = reader.double();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.LowCellVoltageId = reader.int32();
          continue;
        }
        case 15: {
          if (tag !== 121) {
            break;
          }

          message.LowTemperature = reader.double();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.LowThermistorId = reader.int32();
          continue;
        }
        case 17: {
          if (tag !== 137) {
            break;
          }

          message.PackAmphours = reader.double();
          continue;
        }
        case 18: {
          if (tag !== 145) {
            break;
          }

          message.PackCurrent = reader.double();
          continue;
        }
        case 19: {
          if (tag !== 153) {
            break;
          }

          message.PackDepthOfDischarge = reader.double();
          continue;
        }
        case 20: {
          if (tag !== 161) {
            break;
          }

          message.PackStateOfCharge = reader.double();
          continue;
        }
        case 21: {
          if (tag !== 169) {
            break;
          }

          message.PackVoltage = reader.double();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.PopulatedCells = reader.int32();
          continue;
        }
        case 23: {
          if (tag !== 185) {
            break;
          }

          message.RequestedFanSpeed = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IBattery {
    return {
      InputVoltage: isSet(object.InputVoltage) ? globalThis.Number(object.InputVoltage) : 0,
      Alive: isSet(object.Alive) ? globalThis.Boolean(object.Alive) : false,
      AverageCellVoltage: isSet(object.AverageCellVoltage) ? globalThis.Number(object.AverageCellVoltage) : 0,
      AverageTemperature: isSet(object.AverageTemperature) ? globalThis.Number(object.AverageTemperature) : 0,
      BMSRelayStatusFlags: isSet(object.BMSRelayStatusFlags)
        ? IBMSRelayStatusFlags.fromJSON(object.BMSRelayStatusFlags)
        : undefined,
      FanSpeed: isSet(object.FanSpeed) ? globalThis.Number(object.FanSpeed) : 0,
      FanVoltage: isSet(object.FanVoltage) ? globalThis.Number(object.FanVoltage) : 0,
      HighCellVoltage: isSet(object.HighCellVoltage) ? globalThis.Number(object.HighCellVoltage) : 0,
      HighCellVoltageId: isSet(object.HighCellVoltageId) ? globalThis.Number(object.HighCellVoltageId) : 0,
      HighTemperature: isSet(object.HighTemperature) ? globalThis.Number(object.HighTemperature) : 0,
      HighThermistorId: isSet(object.HighThermistorId) ? globalThis.Number(object.HighThermistorId) : 0,
      InternalTemperature: isSet(object.InternalTemperature) ? globalThis.Number(object.InternalTemperature) : 0,
      LowCellVoltage: isSet(object.LowCellVoltage) ? globalThis.Number(object.LowCellVoltage) : 0,
      LowCellVoltageId: isSet(object.LowCellVoltageId) ? globalThis.Number(object.LowCellVoltageId) : 0,
      LowTemperature: isSet(object.LowTemperature) ? globalThis.Number(object.LowTemperature) : 0,
      LowThermistorId: isSet(object.LowThermistorId) ? globalThis.Number(object.LowThermistorId) : 0,
      PackAmphours: isSet(object.PackAmphours) ? globalThis.Number(object.PackAmphours) : 0,
      PackCurrent: isSet(object.PackCurrent) ? globalThis.Number(object.PackCurrent) : 0,
      PackDepthOfDischarge: isSet(object.PackDepthOfDischarge) ? globalThis.Number(object.PackDepthOfDischarge) : 0,
      PackStateOfCharge: isSet(object.PackStateOfCharge) ? globalThis.Number(object.PackStateOfCharge) : 0,
      PackVoltage: isSet(object.PackVoltage) ? globalThis.Number(object.PackVoltage) : 0,
      PopulatedCells: isSet(object.PopulatedCells) ? globalThis.Number(object.PopulatedCells) : 0,
      RequestedFanSpeed: isSet(object.RequestedFanSpeed) ? globalThis.Number(object.RequestedFanSpeed) : 0,
    };
  },

  toJSON(message: IBattery): unknown {
    const obj: any = {};
    if (message.InputVoltage !== 0) {
      obj.InputVoltage = message.InputVoltage;
    }
    if (message.Alive !== false) {
      obj.Alive = message.Alive;
    }
    if (message.AverageCellVoltage !== 0) {
      obj.AverageCellVoltage = message.AverageCellVoltage;
    }
    if (message.AverageTemperature !== 0) {
      obj.AverageTemperature = message.AverageTemperature;
    }
    if (message.BMSRelayStatusFlags !== undefined) {
      obj.BMSRelayStatusFlags = IBMSRelayStatusFlags.toJSON(message.BMSRelayStatusFlags);
    }
    if (message.FanSpeed !== 0) {
      obj.FanSpeed = message.FanSpeed;
    }
    if (message.FanVoltage !== 0) {
      obj.FanVoltage = message.FanVoltage;
    }
    if (message.HighCellVoltage !== 0) {
      obj.HighCellVoltage = message.HighCellVoltage;
    }
    if (message.HighCellVoltageId !== 0) {
      obj.HighCellVoltageId = Math.round(message.HighCellVoltageId);
    }
    if (message.HighTemperature !== 0) {
      obj.HighTemperature = message.HighTemperature;
    }
    if (message.HighThermistorId !== 0) {
      obj.HighThermistorId = Math.round(message.HighThermistorId);
    }
    if (message.InternalTemperature !== 0) {
      obj.InternalTemperature = message.InternalTemperature;
    }
    if (message.LowCellVoltage !== 0) {
      obj.LowCellVoltage = message.LowCellVoltage;
    }
    if (message.LowCellVoltageId !== 0) {
      obj.LowCellVoltageId = Math.round(message.LowCellVoltageId);
    }
    if (message.LowTemperature !== 0) {
      obj.LowTemperature = message.LowTemperature;
    }
    if (message.LowThermistorId !== 0) {
      obj.LowThermistorId = Math.round(message.LowThermistorId);
    }
    if (message.PackAmphours !== 0) {
      obj.PackAmphours = message.PackAmphours;
    }
    if (message.PackCurrent !== 0) {
      obj.PackCurrent = message.PackCurrent;
    }
    if (message.PackDepthOfDischarge !== 0) {
      obj.PackDepthOfDischarge = message.PackDepthOfDischarge;
    }
    if (message.PackStateOfCharge !== 0) {
      obj.PackStateOfCharge = message.PackStateOfCharge;
    }
    if (message.PackVoltage !== 0) {
      obj.PackVoltage = message.PackVoltage;
    }
    if (message.PopulatedCells !== 0) {
      obj.PopulatedCells = Math.round(message.PopulatedCells);
    }
    if (message.RequestedFanSpeed !== 0) {
      obj.RequestedFanSpeed = message.RequestedFanSpeed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IBattery>, I>>(base?: I): IBattery {
    return IBattery.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IBattery>, I>>(object: I): IBattery {
    const message = createBaseIBattery();
    message.InputVoltage = object.InputVoltage ?? 0;
    message.Alive = object.Alive ?? false;
    message.AverageCellVoltage = object.AverageCellVoltage ?? 0;
    message.AverageTemperature = object.AverageTemperature ?? 0;
    message.BMSRelayStatusFlags = (object.BMSRelayStatusFlags !== undefined && object.BMSRelayStatusFlags !== null)
      ? IBMSRelayStatusFlags.fromPartial(object.BMSRelayStatusFlags)
      : undefined;
    message.FanSpeed = object.FanSpeed ?? 0;
    message.FanVoltage = object.FanVoltage ?? 0;
    message.HighCellVoltage = object.HighCellVoltage ?? 0;
    message.HighCellVoltageId = object.HighCellVoltageId ?? 0;
    message.HighTemperature = object.HighTemperature ?? 0;
    message.HighThermistorId = object.HighThermistorId ?? 0;
    message.InternalTemperature = object.InternalTemperature ?? 0;
    message.LowCellVoltage = object.LowCellVoltage ?? 0;
    message.LowCellVoltageId = object.LowCellVoltageId ?? 0;
    message.LowTemperature = object.LowTemperature ?? 0;
    message.LowThermistorId = object.LowThermistorId ?? 0;
    message.PackAmphours = object.PackAmphours ?? 0;
    message.PackCurrent = object.PackCurrent ?? 0;
    message.PackDepthOfDischarge = object.PackDepthOfDischarge ?? 0;
    message.PackStateOfCharge = object.PackStateOfCharge ?? 0;
    message.PackVoltage = object.PackVoltage ?? 0;
    message.PopulatedCells = object.PopulatedCells ?? 0;
    message.RequestedFanSpeed = object.RequestedFanSpeed ?? 0;
    return message;
  },
};

function createBaseIBMSRelayStatusFlags(): IBMSRelayStatusFlags {
  return {
    AlwaysOnSignalStatus: false,
    ChargeRelayEnabled: false,
    ChargerSafetyEnabled: false,
    DischargeRelayEnabled: false,
    IsChargingSignalStatus: false,
    IsReadySignalStatus: false,
    MalfunctionIndicatorActive: false,
    MultiPurposeInputSignalStatus: false,
  };
}

export const IBMSRelayStatusFlags: MessageFns<IBMSRelayStatusFlags> = {
  encode(message: IBMSRelayStatusFlags, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.AlwaysOnSignalStatus !== false) {
      writer.uint32(8).bool(message.AlwaysOnSignalStatus);
    }
    if (message.ChargeRelayEnabled !== false) {
      writer.uint32(16).bool(message.ChargeRelayEnabled);
    }
    if (message.ChargerSafetyEnabled !== false) {
      writer.uint32(24).bool(message.ChargerSafetyEnabled);
    }
    if (message.DischargeRelayEnabled !== false) {
      writer.uint32(32).bool(message.DischargeRelayEnabled);
    }
    if (message.IsChargingSignalStatus !== false) {
      writer.uint32(40).bool(message.IsChargingSignalStatus);
    }
    if (message.IsReadySignalStatus !== false) {
      writer.uint32(48).bool(message.IsReadySignalStatus);
    }
    if (message.MalfunctionIndicatorActive !== false) {
      writer.uint32(56).bool(message.MalfunctionIndicatorActive);
    }
    if (message.MultiPurposeInputSignalStatus !== false) {
      writer.uint32(64).bool(message.MultiPurposeInputSignalStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IBMSRelayStatusFlags {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIBMSRelayStatusFlags();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.AlwaysOnSignalStatus = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.ChargeRelayEnabled = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.ChargerSafetyEnabled = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.DischargeRelayEnabled = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.IsChargingSignalStatus = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.IsReadySignalStatus = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.MalfunctionIndicatorActive = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.MultiPurposeInputSignalStatus = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IBMSRelayStatusFlags {
    return {
      AlwaysOnSignalStatus: isSet(object.AlwaysOnSignalStatus)
        ? globalThis.Boolean(object.AlwaysOnSignalStatus)
        : false,
      ChargeRelayEnabled: isSet(object.ChargeRelayEnabled) ? globalThis.Boolean(object.ChargeRelayEnabled) : false,
      ChargerSafetyEnabled: isSet(object.ChargerSafetyEnabled)
        ? globalThis.Boolean(object.ChargerSafetyEnabled)
        : false,
      DischargeRelayEnabled: isSet(object.DischargeRelayEnabled)
        ? globalThis.Boolean(object.DischargeRelayEnabled)
        : false,
      IsChargingSignalStatus: isSet(object.IsChargingSignalStatus)
        ? globalThis.Boolean(object.IsChargingSignalStatus)
        : false,
      IsReadySignalStatus: isSet(object.IsReadySignalStatus) ? globalThis.Boolean(object.IsReadySignalStatus) : false,
      MalfunctionIndicatorActive: isSet(object.MalfunctionIndicatorActive)
        ? globalThis.Boolean(object.MalfunctionIndicatorActive)
        : false,
      MultiPurposeInputSignalStatus: isSet(object.MultiPurposeInputSignalStatus)
        ? globalThis.Boolean(object.MultiPurposeInputSignalStatus)
        : false,
    };
  },

  toJSON(message: IBMSRelayStatusFlags): unknown {
    const obj: any = {};
    if (message.AlwaysOnSignalStatus !== false) {
      obj.AlwaysOnSignalStatus = message.AlwaysOnSignalStatus;
    }
    if (message.ChargeRelayEnabled !== false) {
      obj.ChargeRelayEnabled = message.ChargeRelayEnabled;
    }
    if (message.ChargerSafetyEnabled !== false) {
      obj.ChargerSafetyEnabled = message.ChargerSafetyEnabled;
    }
    if (message.DischargeRelayEnabled !== false) {
      obj.DischargeRelayEnabled = message.DischargeRelayEnabled;
    }
    if (message.IsChargingSignalStatus !== false) {
      obj.IsChargingSignalStatus = message.IsChargingSignalStatus;
    }
    if (message.IsReadySignalStatus !== false) {
      obj.IsReadySignalStatus = message.IsReadySignalStatus;
    }
    if (message.MalfunctionIndicatorActive !== false) {
      obj.MalfunctionIndicatorActive = message.MalfunctionIndicatorActive;
    }
    if (message.MultiPurposeInputSignalStatus !== false) {
      obj.MultiPurposeInputSignalStatus = message.MultiPurposeInputSignalStatus;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IBMSRelayStatusFlags>, I>>(base?: I): IBMSRelayStatusFlags {
    return IBMSRelayStatusFlags.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IBMSRelayStatusFlags>, I>>(object: I): IBMSRelayStatusFlags {
    const message = createBaseIBMSRelayStatusFlags();
    message.AlwaysOnSignalStatus = object.AlwaysOnSignalStatus ?? false;
    message.ChargeRelayEnabled = object.ChargeRelayEnabled ?? false;
    message.ChargerSafetyEnabled = object.ChargerSafetyEnabled ?? false;
    message.DischargeRelayEnabled = object.DischargeRelayEnabled ?? false;
    message.IsChargingSignalStatus = object.IsChargingSignalStatus ?? false;
    message.IsReadySignalStatus = object.IsReadySignalStatus ?? false;
    message.MalfunctionIndicatorActive = object.MalfunctionIndicatorActive ?? false;
    message.MultiPurposeInputSignalStatus = object.MultiPurposeInputSignalStatus ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
